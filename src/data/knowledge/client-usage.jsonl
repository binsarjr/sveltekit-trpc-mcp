{"question":"How do you call tRPC procedures in SvelteKit pages?","answer":"Use the tRPC client in load functions or component scripts. In load functions: `await trpc(event).users.list.query()`. In components, create a client instance and call procedures: `const result = await trpc().users.list.query()`. All calls are fully type-safe."}
{"question":"How do you use tRPC in SvelteKit load functions?","answer":"Import your tRPC client and call procedures in +page.ts or +page.server.ts load functions. Use the event parameter to create a client instance: `export const load = async (event) => ({ users: await trpc(event).users.list.query() })`. This provides SSR-ready data to your page."}
{"question":"How do you handle tRPC errors on the client side?","answer":"Use try-catch blocks around tRPC calls to handle errors. tRPC provides `TRPCClientError` for error handling with access to error codes, messages, and data. Check error codes to implement appropriate user feedback and error recovery strategies."}
{"question":"How do you implement optimistic updates with tRPC?","answer":"For optimistic updates, immediately update your local state before the mutation completes, then handle success/failure accordingly. Use SvelteKit's stores or reactive state to manage optimistic data, reverting changes if the mutation fails or confirming them on success."}
{"question":"How do you use tRPC with SvelteKit's reactive stores?","answer":"Wrap tRPC calls in Svelte stores to manage reactive state. Create custom stores that call tRPC procedures and update their values. Use derived stores for computed data based on tRPC responses, enabling reactive UI updates when data changes."}
{"question":"How do you handle loading states with tRPC in SvelteKit?","answer":"Implement loading states by tracking promise states in your components. Use reactive variables to show loading indicators while tRPC calls are in progress. In load functions, loading is handled automatically by SvelteKit's navigation system."}