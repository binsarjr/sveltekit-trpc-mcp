{"question":"What is Svelte?","answer":"Svelte is a framework for building user interfaces on the web. It utilizes a compiler to transform declarative components written in HTML, CSS, and JavaScript into optimized JavaScript. [cite: 1, 3] This allows Svelte to be used for building various web applications, from standalone components to full-stack applications with SvelteKit. [cite: 4] For new users, it is recommended to start with the interactive tutorial and refer to the documentation for questions. [cite: 5] Svelte can also be tried online in the playground or on StackBlitz for a more fully-featured environment. [cite: 6]"}
{"question":"How do you get started with Svelte?","answer":"The recommended way to get started with Svelte is by using SvelteKit, its official application framework, which is powered by Vite. [cite: 7, 8] You can create a new project by running `npx sv create myapp`, navigating into the directory with `cd myapp`, installing dependencies with `npm install`, and running the development server with `npm run dev`. [cite: 9] New Svelte users can initially focus on Svelte itself and explore SvelteKit's features later. [cite: 10]\n\nAlternatively, Svelte can be used directly with Vite by running `npm create vite@latest` and selecting the `svelte` option. [cite: 11] This setup uses `vite-plugin-svelte` to generate HTML, JS, and CSS files in the `dist` directory upon building. [cite: 12] In most cases, you would also need to choose a routing library. [cite: 13] While Vite is often used for single-page applications (SPAs), SvelteKit can also build SPAs. [cite: 14] Other build tool plugins exist for Rollup and Webpack, but Vite is recommended. [cite: 15]"}
{"question":"What are `.svelte` files?","answer":"`.svelte` files are where components, the building blocks of Svelte applications, are written. [cite: 20] These files use a superset of HTML and can optionally include script, style, and markup sections. [cite: 21]\n\nScript blocks (`<script>`) contain JavaScript (or TypeScript with `lang=\"ts\"`) that executes when a component instance is created. [cite: 23] Top-level variables and imports within this block can be referenced in the component's markup. [cite: 24] Svelte 5 introduces *runes* like `$props` and reactivity features within script blocks, which are keywords with a `$` prefix and behave differently from normal JavaScript functions. [cite: 25, 39, 40]\n\nScript modules (`<script module>`) run once when the module is first evaluated, not for each component instance. [cite: 26] Variables declared here can be referenced elsewhere in the component, but not vice-versa. [cite: 27] Bindings can be exported from this block, but `export default` is not allowed as the default export is the component itself. [cite: 29, 30] This module-level script concept was introduced in Svelte 5 as `<script module>`, replacing the Svelte 4 syntax of `<script context=\"module\">`. [cite: 26, 30]\n\nStyle blocks (`<style>`) contain CSS that is scoped to that specific component by default, ensuring styles do not affect elements outside the component. [cite: 31, 32]"}
{"question":"What are `.svelte.js` and `.svelte.ts` files?","answer":"In addition to `.svelte` files, Svelte also supports `.svelte.js` and `.svelte.ts` files. [cite: 33] These files function like standard `.js` or `.ts` modules, but they uniquely allow the use of runes. [cite: 34] This capability is beneficial for creating reusable reactive logic or sharing reactive state across your application. [cite: 34] However, note that reassigned state cannot be exported from these files. [cite: 34] This file type is a new concept introduced in Svelte 5. [cite: 35]"}
{"question":"What are runes in Svelte?","answer":"Runes are symbols used in `.svelte` and `.svelte.js`/`.svelte.ts` files that control the Svelte compiler. [cite: 37] They are considered part of the Svelte language syntax, acting as keywords. [cite: 38] Runes are prefixed with a `$` and appear similar to functions, for example, `$state('hello')`. [cite: 39, 40]\n\nKey differences from normal JavaScript functions include: [cite: 40]\n* They do not need to be imported. [cite: 40]\n* They are not values, meaning they cannot be assigned to variables or passed as arguments. [cite: 40]\n* They are only valid in specific positions, similar to JavaScript keywords, and the compiler will assist if they are placed incorrectly. [cite: 40]\n\nRunes were introduced in Svelte 5. [cite: 40]"}
{"question":"How do you manage reactive state in Svelte 5?","answer":"In Svelte 5, reactive state is managed using the `$state` rune. This rune enables the UI to automatically update when the state changes. [cite: 41]\n\nFor example:\n```svelte\n<script>\n\tlet count = $state(0);\n</script>\n\n<button onclick={() => count++}>\n\tclicks: {count}\n</button>\n```\nWith `$state`, variables behave like ordinary numbers or objects, and you can update them directly without needing a special API. [cite: 42]\n\nWhen `$state` is used with arrays or simple objects, it creates a deeply reactive *state proxy*. [cite: 43] These proxies allow Svelte to execute code when properties are read or written, including through array methods like `array.push(...)`, which triggers granular updates. [cite: 44] This proxification applies recursively to nested arrays and simple objects. [cite: 45]\n\nFor example:\n```js\nlet todos = $state([\n\t{\n\t\tdone: false,\n\t\ttext: 'add more todos'\n\t}\n]);\n```\nModifying a property of an individual todo, like `todos[0].done = !todos[0].done;`, will cause UI updates that depend on that specific property. [cite: 46, 47] New objects pushed to the array, like `{ done: false, text: 'eat lunch' }`, will also be proxified. [cite: 48]\n\nHowever, destructuring a reactive value, such as `let { done, text } = todos[0];`, results in non-reactive references, as they are evaluated at the point of destructuring. Subsequent changes to the original reactive value will not affect the destructured variables. [cite: 49, 50]\n\n`$state` can also be used in class fields (public or private): [cite: 51]\n```js\nclass Todo {\n\tdone = $state(false);\n\ttext = $state();\n\n\tconstructor(text) {\n\t\tthis.text = text;\n\t}\n\n\treset() {\n\t\tthis.text = '';\n\t\tthis.done = false;\n\t}\n}\n```\nWhen calling methods, the value of `this` is important. If `this` refers to the `<button>` element in an `onclick` handler (e.g., `<button onclick={todo.reset}>`), the `reset` method's `this` context will be incorrect. [cite: 53] To resolve this, use an inline function (`<button onclick={() => todo.reset()}>`) or define the method as an arrow function in the class. [cite: 54, 55]\n\nFor cases where deep reactivity is not desired for objects and arrays, you can use `$state.raw`. [cite: 56] State declared with `$state.raw` cannot be mutated directly; it must be *reassigned* to update it. [cite: 57]\n\nFor instance:\n```js\nlet person = $state.raw({\n\tname: 'Heraclitus',\n\tage: 49\n});\n// this will have no effect\nperson.age += 1;\n\n// this will work, because we're creating a new person\nperson = {\n\tname: 'Heraclitus',\n\tage: 50\n};\n```\nUsing `$state.raw` can improve performance with large, non-mutating arrays and objects by avoiding the overhead of making them reactive. [cite: 60] However, raw state can still contain reactive state. [cite: 61]\n\nTo obtain a static snapshot of a deeply reactive `$state` proxy, use `$state.snapshot`. [cite: 62]\n```svelte\n<script>\n\tlet counter = $state({ count: 0 });\n\tfunction onclick() {\n\t\t// Will log `{ count: ... }` rather than `Proxy { ... }`\n\t\tconsole.log($state.snapshot(counter));\n\t}\n</script>\n```\nThis is useful when passing state to external libraries or APIs that do not expect a proxy. [cite: 64]"}
{"question":"How do you handle derived state in Svelte 5?","answer":"Derived state in Svelte 5 is declared using the `$derived.by` rune, which ensures that your UI automatically updates when the underlying state changes. [cite: 83, 87]\n\nFor example:\n```svelte\n<script>\n\tlet count = $state(0);\n\tlet doubled = $derived.by(() => count * 2);\n</script>\n\n<button onclick={() => count++}>\n\t{doubled}\n</button>\n\n<p>{count} doubled is {doubled}</p>\n```\nThe expression within `$derived.by` should be free of side-effects, and Svelte will prevent state changes (e.g., `count++`) inside derived expressions. [cite: 84] Class fields can also be marked as `$derived`. [cite: 85]\n\nFor more complex derivations that don't fit into a simple expression, `$derived.by` accepts a function: [cite: 86]\n```svelte\n<script>\n\tlet numbers = $state([1, 2, 3]);\n\tlet total = $derived.by(() => {\n\t\tlet total = 0;\n\t\tfor (const n of numbers) {\n\t\t\ttotal += n;\n\t\t}\n\t\treturn total;\n\t});\n</script>\n\n<button onclick={() => numbers.push(numbers.length + 1)}>\n\t{numbers.join(' + ')} = {total}\n</button>\n```\nEssentially, `$derived(expression)` is equivalent to `$derived.by(() => expression)`. [cite: 89]\n\nAny reactive state (`$state`, `$derived`, `$props`) read synchronously within the `$derived.by` function is considered a *dependency*. [cite: 90] When a dependency changes, the derived value is marked as 'dirty' and recalculated on its next read. [cite: 91] To prevent a piece of state from being a dependency, use `untrack`. [cite: 92]\n\nDerived values can be temporarily overridden by reassignment (unless declared with `const`). This is useful for *optimistic UI*, where immediate user feedback is desired before a server update. [cite: 93]\n\nExample:\n```svelte\n<script>\n\tlet { post, like } = $props();\n\tlet likes = $derived.by(() => post.likes);\n\n\tasync function onclick() {\n\t\t// increment the `likes` count immediately...\n\t\tlikes += 1;\n\t\t// and tell the server, which will eventually update `post`\n\t\ttry {\n\t\t\tawait like();\n\t\t} catch {\n\t\t\t// failed!\n\t\t\t// roll back the change\n\t\t\tlikes -= 1;\n\t\t}\n\t}\n</script>\n\n<button {onclick}>ðŸ§¡ {likes}</button>\n```\nUnlike `$state`, `$derived` values are not automatically converted into deeply reactive proxies; they are left as-is. [cite: 97] If the underlying `$state` is deeply reactive, changes to properties of a `$derived` object will affect the original data. [cite: 98, 99] If the underlying data is *not* deeply reactive, mutating the derived object will have no effect. [cite: 100]\n\nSvelte uses *push-pull reactivity*. When state is updated, dependent elements are notified immediately ('push'), but derived values are only re-evaluated when read ('pull'). [cite: 101] If a derived value's new value is referentially identical to its previous value, downstream updates are skipped. [cite: 102]"}
{"question":"How do you handle side effects in Svelte 5?","answer":"In Svelte 5, side effects are handled using the `$effect` rune. Effects are functions that run when state updates and are suitable for tasks like interacting with third-party libraries, drawing on canvas elements, or making network requests. [cite: 104] They execute only in the browser, not during server-side rendering. [cite: 105]\n\nGenerally, you should avoid updating state directly within effects, as this can lead to convoluted code and potential infinite update cycles. [cite: 106] If you find yourself doing this, consider alternative approaches discussed in the \"When not to use `$effect`\" section. [cite: 107]\n\nHere's an example of using `$effect`:\n```svelte\n<script>\n\tlet size = $state(50);\n\tlet color = $state('#ff3e00');\n\n\tlet canvas;\n\t$effect(() => {\n\t\tconst context = canvas.getContext('2d');\n\t\tcontext.clearRect(0, 0, canvas.width, canvas.height);\n\n\t\t// this will re-run whenever `color` or `size` change\n\t\tcontext.fillStyle = color;\n\t\tcontext.fillRect(0, 0, size, size);\n\t});\n</script>\n\n<canvas bind:this={canvas} width=\"100\" height=\"100\"></canvas>\n```\nWhen Svelte runs an effect function, it automatically tracks reactive state (`$state`, `$derived`, `$props`) accessed synchronously within its body (unless untracked with `untrack`). [cite: 110] The function then re-runs when those tracked dependencies change. [cite: 110, 117]\n\nEffects run after the component is mounted to the DOM and in a microtask after state changes. [cite: 111] Re-runs are batched, and occur after any DOM updates. [cite: 112] `$effect` can be used anywhere, as long as it's called while a parent effect is running. [cite: 113]\n\nAn effect can return a *teardown function*, which executes immediately before the effect re-runs or when the effect is destroyed (e.g., when the component is unmounted or a parent effect re-runs). [cite: 113, 116]\n\nExample with a teardown function:\n```svelte\n<script>\n\tlet count = $state(0);\n\tlet milliseconds = $state(1000);\n\n\t$effect(() => {\n\t\t// This will be recreated whenever `milliseconds` changes\n\t\tconst interval = setInterval(() => {\n\t\t\tcount += 1;\n\t\t}, milliseconds);\n\n\t\treturn () => {\n\t\t\t// if a teardown function is provided, it will run\n\t\t\t// a) immediately before the effect re-runs\n\t\t\t// b) when the component is destroyed\n\t\t\tclearInterval(interval);\n\t\t};\n\t});\n</script>\n\n<h1>{count}</h1>\n\n<button onclick={() => (milliseconds *= 2)}>slower</button>\n<button onclick={() => (milliseconds /= 2)}>faster</button>\n```\n\nValues read *asynchronously* (e.g., after `await` or inside `setTimeout`) are *not* tracked as dependencies. [cite: 119] An effect only reruns when the object it reads changes, not when a property within that object changes. [cite: 123]\n\nTo run code *before* DOM updates, use the `$effect.pre` rune. [cite: 135] Aside from timing, `$effect.pre` functions identically to `$effect`. [cite: 138]\n\nThe `$effect.tracking` rune (available since Svelte 5.11.0) indicates whether code is running within a tracking context, such as an effect or template. [cite: 139] The `$effect.root` rune (available since Svelte 5.11.0) creates a non-tracked scope that does not auto-cleanup, useful for manual control of nested effects or creating effects outside component initialization. [cite: 141, 142]\n\nIt is generally recommended to use `$effect` as an escape hatch for analytics or direct DOM manipulation, rather than for synchronizing state. [cite: 145] For derived values, `$derived` is the preferred rune. [cite: 147] For linking values, use `oninput` callbacks or function bindings instead of effects. [cite: 156]"}
{"question":"How are props handled in Svelte 5?","answer":"In Svelte 5, inputs to a component, known as *props*, are received using the `$props` rune. [cite: 157, 159] You typically destructure the props for easier access. [cite: 160]\n\nExample of `MyComponent.svelte`:\n```svelte\n<!file: MyComponent.svelte>\n<script>\n\tlet{ adjective }= $props();\n</script>\n\n<p>this component is {adjective}</p>\n```\nProps are passed to components like attributes to HTML elements: [cite: 158]\n```svelte\n<!file: App.svelte>\n<script>\n\timport MyComponent from './MyComponent.svelte';\n</script>\n\n<MyComponent adjective=\"cool\" />\n```\n\n**Fallback Values**: You can declare fallback values within destructuring, which are used if the parent component does not provide a value for a specific prop. [cite: 161]\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n**Renaming Props**: Destructuring assignment also allows renaming props, which is useful for invalid identifiers or JavaScript keywords (e.g., `super`). [cite: 162]\n\n**Rest Props**: A rest property can be used to gather all remaining props that aren't explicitly destructured. [cite: 163]\n```js\nlet { a, b, c, ...others } = $props();\n```\n\n**Updating Props**: References to a prop inside a component update when the prop itself changes in the parent. [cite: 164] The child component can temporarily override the prop value for ephemeral state. [cite: 164, 165, 166]\n\nHowever, you should not *mutate* props unless they are explicitly marked as bindable with `$bindable`. [cite: 167] If a prop is a regular object, direct mutation in the child component will have no effect. [cite: 168, 169] If the prop is a reactive state proxy, mutations *will* affect the original object, but Svelte will issue a warning (`ownership_invalid_mutation`) because the child is modifying state it doesn't own. [cite: 170, 171, 172] Fallback values for non-bindable props are not converted to reactive state proxies, so mutations to them will not trigger updates. [cite: 173]\n\nIn summary, it's best to avoid mutating props. Instead, use callback props to communicate changes back to the parent, or use the `$bindable` rune if the parent and child need to share and mutually modify the same object. [cite: 174, 175]\n\n**Type Safety**: You can add type safety to props by annotating them with TypeScript or JSDoc. [cite: 176, 177, 178] It's recommended to add types to ensure clear prop discovery for component users. [cite: 180]\n\n**`$props.id()`**: This rune, added in Svelte 5.20.0, generates an ID unique to the current component instance, consistent between server and client rendering. [cite: 181, 182] It's useful for linking elements with attributes like `for` and `aria-labelledby`. [cite: 183]"}
{"question":"What is `$bindable` in Svelte?","answer":"The `$bindable` rune in Svelte 5 is used to mark a component prop as bindable, allowing data to flow from child to parent, in addition to the usual one-way flow from parent to child. [cite: 184, 186, 188] This also means that a state proxy prop can be mutated in the child component. [cite: 187]\n\nExample of a bindable prop in `FancyInput.svelte`:\n```svelte\n/// file: FancyInput.svelte\n<script>\n\tlet { value = $bindable(), ...props } = $props();\n</script>\n\n<input bind:value={value} {...props} />\n\n<style>\n\tinput {\n\t\tfont-family: 'Comic Sans MS';\n\t\tcolor: deeppink;\n\t}\n</style>\n```\nA component using `<FancyInput>` can then use the `bind:` directive: [cite: 191]\n```svelte\n/// file: App.svelte\n<script>\n\timport FancyInput from './FancyInput.svelte';\n\tlet message = $state('hello');\n</script>\n\n<FancyInput bind:value={message} />\n<p>{message}</p>\n```\nThe parent component is not obligated to use `bind:`. [cite: 192] A fallback value can also be specified for `value` when no prop is passed. [cite: 193, 194]"}
{"question":"How does `$inspect` work in Svelte 5?","answer":"The `$inspect` rune in Svelte 5 functions similarly to `console.log`, but it automatically re-runs and logs its arguments whenever they change. [cite: 195] It tracks reactive state deeply, meaning updates within an object or array declared with fine-grained reactivity will trigger it to re-fire. [cite: 195]\n\nExample:\n```svelte\n<script>\n\tlet count = $state(0);\n\tlet message = $state('hello');\n\n\t$inspect(count, message); // will console.log when `count` or `message` change\n</script>\n\n<button onclick={() => count++}>Increment</button>\n<input bind:value={message} />\n```\n\n`$inspect` also returns a `with` property, which can be invoked with a callback function instead of `console.log`. [cite: 197] The first argument to this callback will be either `\"init\"` or `\"update\"`, followed by the values passed to `$inspect`. [cite: 198]\n\nExample using `with`:\n```svelte\n<script>\n\tlet count = $state(0);\n\t$inspect(count).with((type, count) => {\n\t\tif (type === 'update') {\n\t\t\tdebugger; // or `console.trace`, or whatever you want\n\t\t}\n\t});\n</script>\n\n<button onclick={() => count++}>Increment</button>\n```\nA convenient way to trace the origin of a change is to pass `console.trace` to `with`. [cite: 201]\n\nSince Svelte 5.14, the `$inspect.trace(...)` rune causes the surrounding function to be *traced* in development. [cite: 202] Whenever the function re-runs as part of an effect or derived value, information about the reactive state that caused the re-run will be printed to the console. [cite: 203] `$inspect.trace` can also accept an optional label as its first argument. [cite: 204]"}
{"question":"How do you access the host element in Svelte 5 custom elements?","answer":"When compiling a component as a custom element, the `$host` rune provides access to the host element. [cite: 205] This allows you to perform actions like dispatching custom events directly from the component. [cite: 205]\n\nExample in `Stepper.svelte` (compiled as `my-stepper` custom element): \n```svelte\n/// file: Stepper.svelte\n<svelte:options customElement=\"my-stepper\" />\n\n<script>\n\tfunction dispatch(type) {\n\t\t$host().dispatchEvent(new CustomEvent(type));\n\t}\n</script>\n\n<button onclick={() => dispatch('decrement')}>decrement</button>\n<button onclick={() => dispatch('increment')}>increment</button>\n```\n\nThen, in a parent `App.svelte`:\n```svelte\n/// file: App.svelte\n<script>\n\timport './Stepper.svelte';\n\n\tlet count = $state(0);\n</script>\n\n<my-stepper\n\tondecrement={() => count -= 1}\n\tonincrement={() => count += 1}\n></my-stepper>\n\n<p>count: {count}</p>\n```"}
{"question":"What are the basics of Svelte template markup?","answer":"Svelte template markup extends HTML with additional features. [cite: 207]\n\n**Tags**: Lowercase tags like `<div>` denote standard HTML elements. [cite: 208] Capitalized tags or tags using dot notation, such as `<Widget>` or `<my.stuff>`, indicate a Svelte component. [cite: 209]\n\n**Element Attributes**: By default, attributes behave like HTML attributes. [cite: 210] Values can be unquoted. [cite: 210] Attribute values can contain JavaScript expressions (e.g., `<a href=\"page/{p}\">`) or *be* JavaScript expressions (e.g., `<button disabled={!clickable}>`). [cite: 211] Boolean attributes are included if their value is truthy and excluded if falsy. [cite: 212] Other attributes are included unless their value is nullish (`null` or `undefined`). [cite: 213] When the attribute name and value match (e.g., `disabled={disabled}`), a shorthand `{disabled}` can be used. [cite: 214]\n\n**Component Props**: Values passed to components are called *properties* or *props*. [cite: 215] Similar to element attributes, the `{name}` shorthand can be used when the prop name and value match. [cite: 216] *Spread attributes* (`{...things}`) allow passing multiple attributes or properties to an element or component at once, and multiple spread attributes can be combined with regular ones. [cite: 217, 218]\n\n**Events**: DOM events are handled by adding `on` prefixed attributes (e.g., `onclick`). [cite: 219] Event attributes are case-sensitive. [cite: 220, 221] The same rules as for attributes apply to event attributes, including shorthand and spreading. [cite: 222] Event attributes always fire after events from bindings (e.g., `oninput` after `bind:value`). [cite: 223] Some event handlers are attached directly, while others are *delegated* for performance. [cite: 224] `ontouchstart` and `ontouchmove` handlers are passive by default for better performance, allowing the browser to scroll immediately. [cite: 225] For rare cases requiring `event.preventDefault()` with these, use the `on` function from `svelte/events`. [cite: 226]\n\n**Text Expressions**: JavaScript expressions can be embedded as text by enclosing them in curly braces (e.g., `{expression}`). [cite: 233] HTML entity strings can be used to include curly braces literally. [cite: 234] Regular expression literals need to be wrapped in parentheses. [cite: 235] Expressions are stringified and escaped to prevent code injection; for rendering raw HTML, use the `{@html}` tag. [cite: 237]\n\n**Comments**: HTML comments can be used in components. [cite: 238] Comments starting with `svelte-ignore` disable warnings for the next markup block. [cite: 239] A special `@component` comment can be added for component documentation that appears on hover in other files. [cite: 241]"}
{"question":"How do you conditionally render content in Svelte?","answer":"Content in Svelte can be conditionally rendered using an `{#if ...}` block. [cite: 244]\n\nFor example:\n```svelte\n{#if answer === 42}\n\t<p>what was the question?</p>\n{/if}\n```\nAdditional conditions can be added using `{:else if expression}`, and an optional `{:else}` clause can be included. [cite: 245]\n\nExample with multiple conditions:\n```svelte\n{#if porridge.temperature > 100}\n\t<p>too hot!</p>\n{:else if 80 > porridge.temperature}\n\t<p>too cold!</p>\n{:else}\n\t<p>just right!</p>\n{/if}\n```\nBlocks can wrap both elements and text within elements."}
{"question":"How do you iterate over lists in Svelte?","answer":"Svelte uses `{#each ...}` blocks to iterate over lists of values. [cite: 246] These values can be arrays, array-like objects (those with a `length` property), or iterables like `Map` and `Set` (anything usable with `Array.from`). [cite: 247]\n\nSimple iteration:\n```svelte\n<h1>Shopping list</h1>\n<ul>\n\t{#each items as item}\n\t\t<li>{item.name} x {item.qty}</li>\n\t{/each}\n</ul>\n```\nAn optional `index` can also be specified:\n```svelte\n{#each items as item, i}\n\t<li>{i + 1}: {item.name} x {item.qty}</li>\n{/each}\n```\n\n**Keyed Each Blocks**: Providing a *key* expression (which must uniquely identify each list item) allows Svelte to efficiently diff the list when data changes, rather than adding or removing items from the end. [cite: 248] Strings and numbers are recommended for keys. [cite: 249]\n```svelte\n{#each items as item (item.id)}\n\t<li>{item.name} x {item.qty}</li>\n{/each}\n\n\n{#each items as item, i (item.id)}\n\t<li>{i + 1}: {item.name} x {item.qty}</li>\n{/each}\n```\nDestructuring and rest patterns can be freely used within `each` blocks. [cite: 250]\n\n**Each Blocks Without an Item**: To render something `n` times without needing an item variable, you can omit the `as` part. [cite: 251]\n\n**Else Blocks**: An `{#each ...}` block can include an `{:else}` clause, which renders if the list is empty. [cite: 251]\n```svelte\n{#each todos as todo}\n\t<p>{todo.text}</p>\n{:else}\n\t<p>No tasks today!</p>\n{/each}\n```"}
{"question":"What is the purpose of `{#key ...}` blocks in Svelte?","answer":"The `{#key ...}` block in Svelte is used to destroy and recreate its contents whenever the value of its expression changes. [cite: 252] This is particularly useful for re-instantiating components or replaying transitions when a value changes.\n\nFor example, to re-instantiate a component:\n```svelte\n{#key value}\n\t<Component />\n{/key}\n```\nOr to replay a transition:\n```svelte\n{#key value}\n\t<div transition:fade>{value}</div>\n{/key}\n```"}
{"question":"How do you handle Promises in Svelte templates?","answer":"Svelte provides `{#await ...}` blocks to handle Promises and branch based on their three possible states: pending, fulfilled, or rejected. [cite: 253]\n\nFull example with all states:\n```svelte\n{#await promise}\n\t\n\t<p>waiting for the promise to resolve...</p>\n{:then value}\n\t\n\t<p>The value is {value}</p>\n{:catch error}\n\t\n\t<p>Something went wrong: {error.message}</p>\n{/await}\n```\n\nIf the provided expression is not a `Promise`, only the `:then` branch will be rendered, including during server-side rendering. [cite: 254]\n\n**Omitting `catch` block**: The `catch` block can be omitted if there's no need to render anything when the promise rejects. [cite: 255]\n```svelte\n{#await promise}\n\t\n\t<p>waiting for the promise to resolve...</p>\n{:then value}\n\t\n\t<p>The value is {value}</p>\n{/await}\n```\n\n**Omitting initial block**: If you don't care about the pending state, the initial block can be omitted. [cite: 256]\n```svelte\n{#await promise then value}\n\t<p>The value is {value}</p>\n{/await}\n```\n\n**Showing only error state**: Similarly, if only the error state is relevant, the `then` block can be omitted. [cite: 257]\n```svelte\n{#await promise catch error}\n\t<p>The error is {error}</p>\n{/await}\n```"}
{"question":"How do you create reusable markup in Svelte?","answer":"In Svelte 5, reusable chunks of markup are created using `{#snippet ...}` blocks and rendered with `{@render ...}` tags. [cite: 258] This approach helps to avoid duplicative code.\n\nExample:\n```svelte\n{#snippet figure(image)}\n\t<figure>\n\t\t<img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n\t\t<figcaption>{image.caption}</figcaption>\n\t</figure>\n{/snippet}\n\n{#each images as image}\n\t{#if image.href}\n\t\t<a href={image.href}>\n\t\t\t{@render figure(image)}\n\t\t</a>\n\t{:else}\n\t\t{@render figure(image)}\n\t{/if}\n{/each}\n```\nSnippets can have an arbitrary number of parameters, including default values, and parameters can be destructured. [cite: 259] Rest parameters are not supported. [cite: 259]\n\n**Snippet Scope**: Snippets can be declared anywhere in the component and can reference values from their outer scope (e.g., from the `<script>` tag or `{#each}` blocks). [cite: 260] They are 'visible' to elements within the same lexical scope (siblings and children of those siblings). [cite: 260]\n\nSnippets can also reference themselves and other snippets. [cite: 261]\n\n**Passing Snippets to Components**: Snippets are first-class values and can be passed to components as props. [cite: 262, 265]\n\nExample of passing snippets as props:\n```svelte\n<script>\n\timport Table from './Table.svelte';\n\tconst fruits = [\n\t\t{ name: 'apples', qty: 5, price: 2 },\n\t\t{ name: 'bananas', qty: 10, price: 1 },\n\t\t{ name: 'cherries', qty: 20, price: 0.5 }\n\t];\n</script>\n\n{#snippet header()}\n\t<th>fruit</th>\n\t<th>qty</th>\n\t<th>price</th>\n\t<th>total</th>\n{/snippet}\n\n{#snippet row(d)}\n\t<td>{d.name}</td>\n\t<td>{d.qty}</td>\t\n\t<td>{d.price}</td>\n\t<td>{d.qty * d.price}</td>\n{/snippet}\n\n<Table data={fruits} {header} {row} />\n```\n\nContent inside component tags that is not a snippet declaration implicitly becomes part of the `children` snippet. [cite: 266] This `children` snippet can then be rendered with `{@render children()}`. [cite: 266]\n\nSnippet props can be declared as optional, allowing for conditional rendering using optional chaining (`{@render children?.()}`) or an `{#if}` block with fallback content. [cite: 267, 268, 269]\n\n**Typing Snippets**: Snippets implement the `Snippet` interface imported from `'svelte'`. [cite: 270] The type argument for `Snippet` is a tuple representing the snippet's parameters. [cite: 272] Generics can be used to ensure `data` and `row` refer to the same type. [cite: 273, 274]\n\n**Exporting Snippets**: Top-level snippets in a `.svelte` file can be exported from a `<script module>` for use in other components, provided they don't reference declarations in a non-module `<script>`. [cite: 276] This feature requires Svelte 5.5.0 or newer. [cite: 276]\n\n**Programmatic Snippets**: Snippets can be created programmatically using the `createRawSnippet` API for advanced use cases. [cite: 277]\n\n**Snippets and Slots**: In Svelte 4, `slots` were used for content passing. In Svelte 5, snippets are more powerful and flexible, and `slots` are deprecated. [cite: 278]"}
{"question":"How do you render snippets in Svelte?","answer":"To render a snippet in Svelte, you use the `{@render ...}` tag. [cite: 279]\n\nExample:\n```svelte\n{#snippet sum(a, b)}\n\t<p>{a} + {b} = {a + b}</p>\n{/snippet}\n\n{@render sum(1, 2)}\n{@render sum(3, 4)}\n{@render sum(5, 6)}\n```\nThe expression within `{@render ...}` can be a simple identifier (like `sum`) or an arbitrary JavaScript expression. [cite: 279]\n\n**Optional Snippets**: If a snippet is potentially `undefined` (e.g., an incoming prop), you can use optional chaining (`{@render children?.()}`) to render it only when it's defined. [cite: 279] Alternatively, an `{#if ...}` block with an `{:else}` clause can be used to render fallback content. [cite: 279]"}
{"question":"How do you inject raw HTML into a Svelte component?","answer":"To inject raw HTML into a Svelte component, you use the `{@html ...}` tag. [cite: 279]\n\nExample:\n```svelte\n<article>\n\t{@html content}\n</article>\n```\nThe expression provided to `{@html}` should be valid standalone HTML; it will not work with incomplete tags like `<div>` followed by `</div>` in separate `{@html}` tags. [cite: 280] Also, Svelte code within `{@html}` will not be compiled. [cite: 281]\n\n**Styling**: Content rendered with `{@html}` is 'invisible' to Svelte's scoping mechanisms and will not receive scoped styles directly. [cite: 281] Any styles for elements within the injected HTML will be regarded as unused by the compiler. [cite: 281] To style such content, you need to use the `:global` modifier to target elements inside the container. [cite: 281]\n\nExample:\n```svelte\n<style>\n\tarticle:global{\n\t\ta { color: hotpink }\n\t\timg { width: 100% }\n\t}\n</style>\n```"}
{"question":"How do you define local constants in Svelte templates?","answer":"The `{@const ...}` tag in Svelte is used to define a local constant within a template. [cite: 282]\n\nExample:\n```svelte\n{#each boxes as box}\n\t{@const area = box.width * box.height}\n\t{box.width} * {box.height} = {area}\n{/each}\n```\n`{@const}` is only permitted as an immediate child of a block (such as `{#if ...}`, `{#each ...}`, `{#snippet ...}`), a `<Component />`, or a `<svelte:boundary>`. [cite: 283]"}
{"question":"How does `{@debug ...}` work in Svelte?","answer":"The `{@debug ...}` tag in Svelte serves as an alternative to `console.log(...)`. [cite: 284] It logs the values of specified variables whenever they change and pauses code execution if your developer tools are open. [cite: 285]\n\nExample:\n```svelte\n<script>\n\tlet user = {\n\t\tfirstname: 'Ada',\n\t\tlastname: 'Lovelace'\n\t};\n</script>\n\n{@debug user}\n\n<h1>Hello {user.firstname}!</h1>\n```\n`{@debug ...}` accepts a comma-separated list of variable names; it does not support arbitrary expressions. [cite: 286] A `{@debug}` tag without any arguments will insert a `debugger` statement that triggers when *any* state changes, not just specified variables. [cite: 287]"}
{"question":"How does the `bind:` directive work in Svelte?","answer":"The `bind:` directive in Svelte enables two-way data flow, allowing data to flow from a child component or HTML element back to its parent. [cite: 288, 289] The general syntax is `bind:property={expression}`, where `expression` must be an *lvalue* (a variable or object property). [cite: 290] If the expression is an identifier with the same name as the property, it can be omitted (e.g., `bind:value` is equivalent to `bind:value={value}`). [cite: 290]\n\nSvelte internally creates an event listener that updates the bound value. If an element already has a listener for the same event, that listener fires before the bound value is updated. [cite: 291, 292] Most bindings are two-way, affecting both the element and the bound value, while a few are readonly. [cite: 293, 294]\n\n**Function Bindings**: Available since Svelte 5.9.0, you can use `bind:property={get, set}` with functions for `get` and `set` to perform validation and transformation. [cite: 295] For readonly bindings, the `get` value should be `null`. [cite: 295]\n\n**`<input bind:value>`**: This binds to the input's `value` property. [cite: 296] For numeric inputs (`type=\"number\"` or `type=\"range\"`), the value is coerced to a number. [cite: 297] An empty or invalid numeric input results in an `undefined` value. [cite: 298] Since 5.6.0, if an `<input>` has a `defaultValue` and is part of a form, it reverts to that value (instead of an empty string) on form reset, though the binding's value takes precedence on initial render unless it's `null` or `undefined`. [cite: 299, 300, 301]\n\n**`<input bind:checked>`**: Used for checkbox and radio inputs. [cite: 302] Since 5.6.0, if an `<input>` has a `defaultChecked` attribute and is part of a form, it reverts to that value (instead of `false`) on form reset, with the binding's value taking precedence on initial render unless `null` or `undefined`. [cite: 302, 303]\n\n**`<input bind:group>`**: For inputs that work together (checkboxes or radio buttons). [cite: 304] Radio inputs are mutually exclusive, while checkbox inputs populate an array. [cite: 305]\n\n**`<input bind:files>`**: On file inputs (`type=\"file\"`), this binds to the `FileList` of selected files. [cite: 306] Programmatic updates require a `FileList` object, typically created via `DataTransfer`. [cite: 307, 308, 309] `FileList` objects are immutable; deleting a file requires creating a new `DataTransfer` object. [cite: 310, 311]\n\n**`<select bind:value>`**: Binds to the `value` property of the selected `<option>`, which can be any value. [cite: 312] For `<select multiple>`, the bound variable is an array of selected option values. [cite: 313, 314] The `value` attribute on `<option>` can be omitted if it matches the text content. [cite: 315] A `selected` attribute on an `<option>` sets a default value, which the select element reverts to on form reset. [cite: 316, 317, 318]\n\n**Media Elements (`<audio>`, `<video>`, `<img>`)**: Specific two-way and readonly bindings are available for `<audio>` (e.g., `currentTime`, `paused`, `volume`) and `<video>` (all `<audio>` bindings plus `videoWidth`, `videoHeight`). [cite: 319] `<img>` elements have `naturalWidth` and `naturalHeight` as readonly bindings. [cite: 319]\n\n**`<details bind:open>`**: Binds to the `open` property of a `<details>` element. [cite: 320]\n\n**Contenteditable Bindings**: Elements with `contenteditable` support `innerHTML`, `innerText`, and `textContent` bindings. [cite: 320]\n\n**Dimensions**: All visible elements have readonly bindings for `clientWidth`, `clientHeight`, `offsetWidth`, and `offsetHeight`, measured with a `ResizeObserver`. [cite: 320]\n\n**`bind:this`**: Used to get a reference to a DOM node or a component instance. [cite: 321, 323] The value is `undefined` until the component is mounted. [cite: 322] For components, `bind:this` allows programmatic interaction with exported functions. [cite: 323]\n\n**`bind:_property_` for Components**: You can bind to component props using `bind:property={variable}`. [cite: 324] While Svelte props are reactive downwards by default, `bind:property` allows changes to flow back up. [cite: 325, 326] To enable this, the prop must be marked as bindable using the `$bindable` rune. [cite: 327] Bindable properties can have fallback values, which apply *only* when the property is not bound. [cite: 328, 329] If a bound property has a fallback, a non-`undefined` value is expected from the parent, otherwise a runtime error is thrown to prevent ambiguity. [cite: 330, 331, 332]"}
{"question":"How do you use actions in Svelte?","answer":"Actions in Svelte are functions that are called when an element is mounted to the DOM. [cite: 333] They are applied using the `use:` directive. [cite: 333] Typically, an action will utilize an `$effect` to manage its state and ensure proper cleanup when the element is unmounted. [cite: 333, 334]\n\nExample of an action:\n```svelte\n<!file: App.svelte>\n<script>\n\t/** @type {import('svelte/action').Action} */\n\tfunction myaction(node) {\n\t\t// the node has been mounted in the DOM\n\n\t\t$effect(() => {\n\t\t\t// setup goes here\n\n\t\t\treturn () => {\n\t\t\t\t// teardown goes here\n\t\t\t};\n\t\t});\n\t}\n</script>\n\n<div use:myaction>...</div>\n```\nAn action can also be called with an argument, but the action itself is only called once upon mounting and will *not* re-run if the argument changes. [cite: 335]\n\nPrior to the `$effect` rune, actions returned an object with `update` and `destroy` methods; using effects is now the preferred approach. [cite: 336]\n\n**Typing**: The `Action` interface accepts optional type arguments for the node type, a parameter, and any custom event handlers created by the action. [cite: 337, 338]"}
{"question":"How do you use transitions in Svelte?","answer":"In Svelte, a *transition* is activated when an element enters or leaves the DOM due to a state change. [cite: 339] When a block (like an `{#if ...}` block) transitions out, all its elements, even those without their own transitions, remain in the DOM until all transitions within that block are complete. [cite: 340]\n\nThe `transition:` directive indicates a *bidirectional* transition, allowing for smooth reversal while the transition is in progress. [cite: 341]\n\nExample using a built-in `fade` transition:\n```svelte\n<script>\n\timport { fade } from 'svelte/transition';\n\n\tlet visible = $state(false);\n</script>\n\n<button onclick={() => visible = !visible}>toggle</button>\n\n{#if visible}\n\t<div transition:fade>fades in and out</div>\n{/if}\n```\n\n**Local vs. Global Transitions**: By default, transitions are *local*. [cite: 343] Local transitions only play when their immediate block is created or destroyed, not when parent blocks are created or destroyed. [cite: 344] To make a transition *global*, use the `|global` modifier, which will cause it to play when any control flow block above it is created or destroyed. [cite: 344]\n\n**Built-in Transitions**: Svelte provides a selection of built-in transitions that can be imported from the `svelte/transition` module. [cite: 345]\n\n**Transition Parameters**: Transitions can accept parameters to customize their behavior. [cite: 346]\n```svelte\n{#if visible}\n\t<div transition:fade={{ duration: 2000 }}>fades in and out over two seconds</div>\n{/if}\n```\n\n**Custom Transition Functions**: You can create custom transition functions. [cite: 346] If the returned object from a custom transition function includes a `css` function, Svelte will generate keyframes for a web animation. [cite: 347] The `t` argument in `css` ranges from `0` to `1` after easing, where `1` represents the element's natural state. [cite: 348, 349] The `u` argument is `1 - t`. [cite: 349] The `css` function is called repeatedly before the transition starts. [cite: 350]\n\nExample of a custom transition with a `css` function:\n```svelte\n<!file: App.svelte>\n<script>\n\timport { elasticOut } from 'svelte/easing';\n\n\t/** @type {boolean} */\n\texport let visible;\n\t/**\n\t * @param {HTMLElement} node\n\t * @param {{ delay?: number, duration?: number, easing?: (t: number) => number }} params\n\t */\n\tfunction whoosh(node, params) {\n\t\tconst existingTransform = getComputedStyle(node).transform.replace('none', '');\n\t\treturn {\n\t\t\tdelay: params.delay || 0,\n\t\t\tduration: params.duration || 400,\n\t\t\teasing: params.easing || elasticOut,\n\t\t\tcss: (t, u) => `transform: ${existingTransform} scale(${t})`\n\t\t};\n\t}\n</script>\n\n{#if visible}\n\t<div in:whoosh>whooshes in</div>\n{/if}\n```\nA custom transition function can also return a `tick` function, which is called *during* the transition with the same `t` and `u` arguments. [cite: 354]\n\nIf a transition function returns another function instead of a transition object, that function will be called in the next microtask, allowing multiple transitions to coordinate (e.g., crossfade effects). [cite: 358] Transition functions also receive a third `options` argument with properties like `direction` (`in`, `out`, or `both`). [cite: 359, 360]\n\n**Transition Events**: Elements with transitions dispatch `introstart`, `introend`, `outrostart`, and `outroend` events in addition to standard DOM events. [cite: 361]"}
{"question":"What is the difference between `transition:`, `in:` and `out:` directives?","answer":"The `in:` and `out:` directives are similar to `transition:` but create non-bidirectional transitions. [cite: 361] This means an `in` transition will continue to play alongside an `out` transition if the block is removed while the transition is in progress, rather than reversing. [cite: 361] If an `out` transition is aborted, transitions will restart from scratch. [cite: 362]\n\nExample:\n```svelte\n<script>\n  import { fade, fly } from 'svelte/transition';\n\tlet visible = $state(false);\n</script>\n\n<label>\n  <input type=\"checkbox\" bind:checked={visible}>\n  visible\n</label>\n\n{#if visible}\n\t<div in:fly={{ y: 200 }} out:fade>flies in, fades out</div>\n{/if}\n```"}
{"question":"How do you handle reduced motion in Svelte transitions?","answer":"For accessibility, it's important to respect user preferences for reduced motion. You can disable transitions for users who have this preference enabled in their operating system by using a `@media` query in your CSS. [cite: svelte.dev/blog/view-transitions]\n\nExample:\n```css\n@media (prefers-reduced-motion) {\n\t::view-transition-group(*),\n\t::view-transition-old(*),\n\t::view-transition-new(*) {\n\t\tanimation: none !important;\n\t}\n}\n```"}
{"question":"How do you load page data in SvelteKit?","answer":"In SvelteKit, you can use a `load` function in a `+page.server.js` or `+page.js` file to fetch data for a page before it's rendered. This function runs on the server for `+page.server.js` and on both the server and the client for `+page.js`. The data returned from `load` is available to the corresponding Svelte component via its props. [cite: svelte.dev/tutorial/kit/page-data]\n\nExample of a `load` function in `+page.server.js`:\n```javascript\nimport { posts } from './data.js';\n\nexport function load() {\n\treturn {\n\t\tsummaries: posts.map((post) => ({\n\t\t\tslug: post.slug,\n\t\t\ttitle: post.title\n\t\t}))\n\t};\n}\n```"}
{"question":"How do you handle service workers in SvelteKit?","answer":"SvelteKit provides a simple way to add a service worker to your application. You can create a `src/service-worker.js` file to define your service worker's behavior, such as caching strategies for offline access. The service worker can intercept `fetch` events and respond with cached assets or network requests. [cite: svelte.dev/docs/kit/service-workers]\n\nExample of a caching strategy in a service worker:\n```javascript\nimport { build, files, version } from '$service-worker';\n\nconst CACHE = `cache-${version}`;\n\nconst ASSETS = [\n  ...build, // assets generated by Vite\n  ...files  // assets in your static directory\n];\n\nself.addEventListener('install', (event) => {\n\tasync function addFilesToCache() {\n\t\tconst cache = await caches.open(CACHE);\n\t\tawait cache.addAll(ASSETS);\n\t}\n\n\tevent.waitUntil(addFilesToCache());\n});\n\nself.addEventListener('activate', (event) => {\n\tasync function deleteOldCaches() {\n\t\tfor (const key of await caches.keys()) {\n\t\t\tif (key !== CACHE) await caches.delete(key);\n\t\t}\n\t}\n\n\tevent.waitUntil(deleteOldCaches());\n});\n\nself.addEventListener('fetch', (event) => {\n\tif (event.request.method !== 'GET') return;\n\n\tasync function respond() {\n\t\tconst url = new URL(event.request.url);\n\t\tconst cache = await caches.open(CACHE);\n\n\t\tif (ASSETS.includes(url.pathname)) {\n\t\t\treturn cache.match(url.pathname);\n\t\t}\n\n\t\ttry {\n\t\t\tconst response = await fetch(event.request);\n\n\t\t\tif (response.status === 200) {\n\t\t\t\tcache.put(event.request, response.clone());\n\t\t\t}\n\n\t\t\treturn response;\n\t\t} catch (err) {\n\t\t\treturn cache.match(event.request);\n\t\t}\n\t}\n\n\tevent.respondWith(respond());\n});\n```"}
{"question":"How do you use animations in Svelte?","answer":"Animations in Svelte are triggered when the contents of a [keyed each block](#Keyed-each-blocks) are re-ordered. [cite: 364] Animations do not run when an element is added or removed, only when the index of an existing data item changes within the block. [cite: 365] Animate directives must be placed on an element that is an *immediate* child of a keyed each block. [cite: 366]\n\nAnimations can be used with Svelte's [built-in animation functions](docs/svelte/svelte-animate) or custom animation functions. [cite: 367]\n\nExample:\n```svelte\n\n{#each list as item, index (item)}\n\t<li animate:flip>{item}</li>\n{/each}\n```\n\n**Animation Parameters**: Similar to actions and transitions, animations can accept parameters. [cite: 368]\n```svelte\n{#each list as item, index (item)}\n\t<li animate:flip={{ delay: 500 }}>{item}</li>\n{/each}\n```\n\n**Custom Animation Functions**: Custom animation functions are called with the `node`, an `animation` object (containing `from` and `to` `DOMRect` properties describing the element's start and end geometries), and any `parameters`. [cite: 369, 370, 371]\n\nIf the returned object from a custom animation function includes a `css` method, Svelte will create a web animation. [cite: 372] The `t` argument in `css` goes from `0` to `1` after easing, and `u` is `1 - t`. [cite: 373] The function is called repeatedly before the animation begins. [cite: 374]\n\nExample of a custom animation with a `css` function:\n```svelte\n<!file: App.svelte>\n<script>\n\timport { cubicOut } from 'svelte/easing';\n\n\t/**\n\t * @param {HTMLElement} node\n\t * @param {{ from: DOMRect;\n\t * to: DOMRect }} states\n\t * @param {any} params\n\t */\n\tfunction whizz(node, { from, to }, params) {\n\t\tconst dx = from.left - to.left;\n\t\tconst dy = from.top - to.top;\n\n\t\tconst d = Math.sqrt(dx * dx + dy * dy);\n\t\treturn {\n\t\t\tdelay: 0,\n\t\t\tduration: Math.sqrt(d) * 120,\n\t\t\teasing: cubicOut,\n\t\t\tcss: (t, u) => `transform: translate(${u * dx}px, ${u * dy}px) rotate(${t * 360}deg);`\n\t\t};\n\t}\n</script>\n\n{#each list as item, index (item)}\n\t<div animate:whizz>{item}</div>\n{/each}\n```\nA custom animation function can also return a `tick` function, which is called during the animation with the same `t` and `u` arguments. [cite: 379]\n\nExample of a custom animation with a `tick` function:\n```svelte\n<!file: App.svelte>\n<script>\n\timport { cubicOut } from 'svelte/easing';\n\n\t/**\n\t * @param {HTMLElement} node\n\t * @param {{ from: DOMRect;\n\t * to: DOMRect }} states\n\t * @param {any} params\n\t */\n\tfunction whizz(node, { from, to }, params) {\n\t\tconst dx = from.left - to.left;\n\t\tconst dy = from.top - to.top;\n\n\t\tconst d = Math.sqrt(dx * dx + dy * dy);\n\t\treturn {\n\t\t\tdelay: 0,\n\t\t\tduration: Math.sqrt(d) * 120,\n\t\t\teasing: cubicOut,\n\t\t\ttick: (t, u) => Object.assign(node.style, { color: t > 0.5 ? 'Pink' : 'Blue' })\n\t\t};\n\t}\n</script>\n\n{#each list as item, index (item)}\n\t<div animate:whizz>{item}</div>\n{/each}\n```"}
{"question":"How do you apply styles with the `style:` directive in Svelte?","answer":"The `style:` directive in Svelte provides a shorthand for setting multiple styles on an element. [cite: 384]\n\nExample:\n```svelte\n\n<div style:color=\"red\">...</div>\n<div style=\"color: red;\">...</div>\n```\nThe value can contain arbitrary expressions: [cite: 384]\n```svelte\n<div style:color={myColor}>...</div>\n```\nThe shorthand form is also allowed: [cite: 384]\n```svelte\n<div style:color>...</div>\n```\nMultiple styles can be set on a single element: [cite: 385]\n```svelte\n<div style:color style:width=\"12rem\" style:background-color={darkMode ?\n'black' : 'white'}>...</div>\n```\nTo mark a style as important, use the `|important` modifier: [cite: 385]\n```svelte\n<div style:color|important=\"red\">...</div>\n```\nWhen `style:` directives are combined with `style` attributes, the directives take precedence. [cite: 386]\n```svelte\n<div style=\"color: blue;\"\nstyle:color=\"red\">This will be red</div>\n```"}
{"question":"How do you apply CSS classes in Svelte?","answer":"In Svelte, you can apply CSS classes using either the `class` attribute or the `class:` directive. [cite: 387]\n\n**Using the `class` attribute:**\nPrimitive values are treated like any other attribute: [cite: 388]\n```svelte\n<div class={large ?\n'large' : 'small'}>...</div>\n```\nHistorically, falsy values (like `false` and `NaN`) were stringified, but `undefined` or `null` would cause the attribute to be omitted. [cite: 389] In future Svelte versions, all falsy values will cause the `class` attribute to be omitted. [cite: 390]\n\nSince Svelte 5.16, the `class` attribute can accept an object or an array, which are converted to a string using `clsx`. [cite: 391] If the value is an object, truthy keys are added as class names: [cite: 392]\n```svelte\n<script>\n\tlet { cool } = $props();\n</script>\n\n\n<div class={{ cool, lame: !cool }}>...</div>\n```\nIf the value is an array, truthy values within the array are combined: [cite: 393]\n```svelte\n\n<div class={[faded && 'saturate-0 opacity-50', large && 'scale-200']}>...</div>\n```\nArrays can contain nested arrays and objects, which `clsx` will flatten. This is useful for combining local classes with component props. [cite: 394]\n\nExample combining local classes with props:\n```svelte\n<!file: Button.svelte>\n<script>\n\tlet props = $props();\n</script>\n\n<button {...props} class={['cool-button', props.class]}>\n\t{@render props.children?.()}\n</button>\n```\nThe `ClassValue` type from `svelte/elements` can be used for type-safe class names in component props. [cite: 397, 398]\n\n**Using the `class:` directive (prior to Svelte 5.16):**\nBefore Svelte 5.16, the `class:` directive was commonly used for conditional class assignment. [cite: 399]\n```svelte\n\n<div class={{ cool, lame: !cool }}>...</div>\n<div class:cool={cool} class:lame={!cool}>...</div>\n```\nA shorthand is available when the class name matches the value: [cite: 399]\n```svelte\n<div class:cool class:lame={!cool}>...</div>\n```"}
{"question":"How does Svelte handle scoped styles?","answer":"Svelte components can include a `<style>` element that contains CSS specifically for that component. [cite: 400] By default, this CSS is *scoped*, meaning it will only apply to elements within the component and not to other elements on the page. [cite: 401] Svelte achieves this by adding a unique class (e.g., `svelte-123xyz`) based on a hash of the component's styles to the affected elements. [cite: 402]\n\nExample:\n```svelte\n<style>\n\tp {\n\t\t/* this will only affect <p> elements in this component */\n\t\tcolor: burlywood;\n\t}\n</style>\n```\n\n**Specificity**: Each scoped selector gains a specificity increase of 0-1-0 due to the addition of the scoping class. [cite: 404] This ensures that a `p` selector defined within a component takes precedence over a `p` selector in a global stylesheet, even if the global stylesheet is loaded later. [cite: 405] In some cases, the scoping class is added multiple times, but after the first instance, it's added with `:where(.svelte-xyz123)` to avoid further increasing specificity. [cite: 406]\n\n**Scoped Keyframes**: If a component defines `@keyframes`, their names are also scoped to the component using the same hashing mechanism. [cite: 407] Any `animation` rules within the component are adjusted accordingly. [cite: 408]"}
{"question":"How do you apply global styles in Svelte?","answer":"Svelte provides mechanisms to apply styles globally, overriding the default component-scoped behavior.\n\n**`:global(...)` modifier**: To apply styles to a single selector globally, use the `:global(...)` modifier: [cite: 409]\n```svelte\n<style>\n\t:global(body) {\n\t\t/* applies to <body> */\n\t\tmargin: 0;\n\t}\n\n\tdiv :global(strong) {\n\t\t/* applies to all <strong> elements, in any component,\n\t\t   that are inside <div> elements belonging\n\t\t   to this component */\n\t\tcolor: goldenrod;\n\t}\n\n\tp:global(.big.red) {\n\t\t/* applies to all <p> elements belonging to this component\n\t\t   with `class=\"big red\"`, even if it is applied\n\t\t   programmatically (for example by a library) */\n\t}\n</style>\n```\nFor `@keyframes` to be accessible globally, prepend their names with `-global-`; this prefix will be removed during compilation. [cite: 411, 412]\n\n**`:global` block**: To apply styles to a group of selectors globally, create a `:global {...}` block: [cite: 410]\n```svelte\n<style>\n\t:global {\n\t\t/* applies to every <div> in your application */\n\t\tdiv { ... }\n\n\t\t/* applies to every <p> in your application */\n\t\tp { ... }\n\t}\n\n\t.a :global {\n\t\t/* applies to every `.b .c .d` element, in any component,\n\t\t   that is inside an `.a` element in this component */\n\t\t.b .c .d {...}\n\t}\n</style>\n```"}
{"question":"How do you use CSS custom properties in Svelte?","answer":"Svelte allows you to pass both static and dynamic CSS custom properties to components. [cite: 413]\n\nExample:\n```svelte\n<Slider\n\tbind:value\n\tmin={0}\n\tmax={100}\n\t--track-color=\"black\"\n\t--thumb-color=\"rgb({r} {g} {b})\"\n/>\n```\nThis code essentially translates to wrapping the component in a `svelte-css-wrapper` element (or a `<g>` for SVG elements) with the custom properties set as inline styles. [cite: 413, 414]\n\nInside the component, these custom properties can be read using `var(...)`, with the option to provide fallback values: [cite: 414]\n```svelte\n<style>\n\t.track {\n\t\tbackground: var(--track-color, #aaa);\n\t}\n\n\t.thumb {\n\t\tbackground: var(--thumb-color, blue);\n\t}\n</style>\n```\nCustom properties don't strictly need to be specified directly on the component; they can be defined on any parent element (e.g., the `:root` element in a global stylesheet) and still be accessible within the component. [cite: 414]"}
{"question":"Can you nest `<style>` elements in Svelte?","answer":"While a Svelte component can only have one top-level `<style>` tag, it is possible to nest `<style>` tags inside other elements or logic blocks. [cite: 415]\n\nWhen a `<style>` tag is nested, it is inserted directly into the DOM as-is, meaning no scoping or processing will be applied to it. [cite: 416, 417]\n\nExample:\n```svelte\n<div>\n\t<style>\n\t\t/* this style tag will be inserted as-is */\n\t\tdiv {\n\t\t\t/* this will apply to all `<div>` elements in the DOM */\n\t\t\tcolor: red;\n\t\t}\n\t</style>\n</div>\n```"}
{"question":"What is `<svelte:boundary>` in Svelte?","answer":"The `<svelte:boundary>` element (added in Svelte 5.3.0) allows you to guard against errors in a specific part of your application, preventing them from breaking the entire app, and enabling recovery from those errors. [cite: 419]\n\nIf an error occurs during the rendering or updating of its children, or while running any `$effect` functions contained within the boundary, the boundary's contents will be removed. [cite: 420] However, errors originating outside the rendering process (e.g., in event handlers or after `setTimeout` or async operations) are *not* caught by error boundaries. [cite: 421]\n\nTo function, a boundary must have either the `failed` snippet or the `onerror` property, or both. [cite: 422]\n\n**`failed` snippet**: If a `failed` snippet is provided, it will render with the thrown error and a `reset` function that can be called to recreate the original contents. [cite: 423]\n\nExample with `failed` snippet:\n```svelte\n<svelte:boundary>\n\t<FlakyComponent />\n\n\t{#snippet failed(error, reset)}\n\t\t<button onclick={reset}>oops!\n\t\ttry again</button>\n\t{/snippet}\n</svelte:boundary>\n```\n\n**`onerror` property**: If an `onerror` function is provided, it will be called with the `error` and `reset` arguments. [cite: 425] This is useful for reporting errors to a service or managing error state outside the boundary. [cite: 425]\n\nExample with `onerror` function:\n```svelte\n<script>\n\tlet error = $state(null);\n\tlet reset = $state(() => {});\n\n\tfunction onerror(e, r) {\n\t\terror = e;\n\t\treset = r;\n\t}\n</script>\n\n<svelte:boundary {onerror}>\n\t<FlakyComponent />\n</svelte:boundary>\n\n{#if error}\n\t<button onclick={() => {\n\t\terror = null;\n\t\treset();\n\t}}>\n\t\toops!\n\t\ttry again\n\t</button>\n{/if}\n```\nIf an error occurs within the `onerror` function itself (or if the error is rethrown), it will be handled by a parent boundary if one exists. [cite: 429]"}
{"question":"What are the special Svelte elements for interacting with the DOM?","answer":"Svelte provides several special elements for interacting with the DOM:\n\n**`<svelte:window>`**: This element allows you to add event listeners to the `window` object without worrying about removing them or checking for `window`'s existence during server-side rendering. [cite: 430] It can only appear at the top level of your component. [cite: 431]\n\nExample:\n```svelte\n<script>\n\tfunction handleKeydown(event) {\n\t\talert(`pressed the ${event.key} key`);\n\t}\n</script>\n\n<svelte:window onkeydown={handleKeydown} />\n```\nYou can also bind to `innerWidth`, `innerHeight`, `outerWidth`, `outerHeight`, `scrollX`, `scrollY`, `online` (alias for `window.navigator.onLine`), and `devicePixelRatio`. All except `scrollX` and `scrollY` are readonly. [cite: 432]\n\n**`<svelte:document>`**: Similar to `<svelte:window>`, this element adds listeners to `document` events (e.g., `visibilitychange`) and allows using [actions](docs/svelte/use) on `document`. [cite: 433] It must be at the top level of your component. [cite: 434]\n\nExample:\n```svelte\n<svelte:document onvisibilitychange={handleVisibilityChange} use:someAction />\n```\nYou can bind to `activeElement`, `fullscreenElement`, `pointerLockElement`, and `visibilityState`, all of which are readonly. [cite: 435]\n\n**`<svelte:body>`**: This element adds listeners to `document.body` events (e.g., `mouseenter`, `mouseleave`) and enables [actions](docs/svelte/use) on the `<body>` element. [cite: 436, 437] Like the other special elements, it must be at the top level of your component. [cite: 438]\n\nExample:\n```svelte\n<svelte:body onmouseenter={handleMouseenter} onmouseleave={handleMouseleave} use:someAction />\n```\n\n**`<svelte:head>`**: This element allows you to insert elements into `document.head`. [cite: 439] During server-side rendering, `head` content is exposed separately. [cite: 440] It must be at the top level of your component. [cite: 441]\n\nExample:\n```svelte\n<svelte:head>\n\t<title>Hello world!</title>\n\t<meta name=\"description\" content=\"This is where the description goes for SEO\" />\n</svelte:head>\n```\n\n**`<svelte:element>`**: This element enables rendering an element whose tag name is unknown at author time (e.g., from a CMS). [cite: 442] Properties and event listeners are applied to the element. [cite: 443] The only supported binding is `bind:this` because Svelte's built-in bindings don't work with generic elements. [cite: 444] If `this` is nullish, the element and its children won't render. [cite: 445] If `this` is a void element (e.g., `br`) and `<svelte:element>` has children, a development-mode runtime error is thrown. [cite: 445]\n\nExample:\n```svelte\n<script>\n\tlet tag = $state('hr');\n</script>\n\n<svelte:element this={tag}>\n\tThis text cannot appear inside an hr element\n</svelte:element>\n```\nSvelte tries to infer the correct namespace, but you can explicitly set it with `xmlns`. [cite: 447] The `this` property must be a valid DOM element tag. [cite: 448]"}
{"question":"What is `<svelte:options>` in Svelte?","answer":"The `<svelte:options>` element in Svelte allows you to specify per-component compiler options. [cite: 449] These options are detailed in the [compiler section](docs/svelte/svelte-compiler#compile) of the documentation. [cite: 449]\n\nPossible options include:\n* `runes={true}`: Forces a component into _runes mode_. [cite: 450]\n* `runes={false}`: Forces a component into _legacy mode_. [cite: 450]\n* `namespace=\"...\"`: Specifies the namespace for the component (e.g., \"html\" (default), \"svg\", \"mathml\"). [cite: 450]\n* `customElement={...}`: Provides options for compiling the component as a custom element. If a string is provided, it's used as the `tag` option. [cite: 450]\n* `css=\"injected\"`: The component will inject its styles inline; in SSR, it's a `<style>` tag in the `head`, and in client-side rendering, it's loaded via JavaScript. [cite: 450]\n\nDeprecated options from Svelte 4 that are non-functional in runes mode include: `immutable={true/false}` and `accessors={true/false}`. [cite: 451, 452, 453]\n\nExample:\n```svelte\n<svelte:options customElement=\"my-custom-element\" />\n```"}
{"question":"What are stores in Svelte and when should they be used?","answer":"A *store* in Svelte is an object that provides reactive access to a value through a defined *store contract*. [cite: 455] The `svelte/store` module offers minimal store implementations that fulfill this contract. [cite: 456]\n\nInside a component, you can access a store's value by prefixing its variable name with a `$` (e.g., `$count`). [cite: 457] This prefix triggers Svelte to declare the variable, subscribe to the store during component initialization, and unsubscribe when appropriate. [cite: 458] Assignments to `$`-prefixed variables that are writable stores will result in a call to the store's `.set` method. [cite: 459] Stores must be declared at the top level of a component. [cite: 460] Local variables that do not represent store values must *not* have a `$` prefix. [cite: 460]\n\nExample:\n```svelte\n<script>\n\timport { writable } from 'svelte/store';\n\tconst count = writable(0);\n\tconsole.log($count); // logs 0\n\n\tcount.set(1);\n\tconsole.log($count); // logs 1\n\n\t$count = 2;\n\tconsole.log($count); // logs 2\n</script>\n```\n\n**When to use stores**: Prior to Svelte 5, stores were the primary solution for cross-component reactive states or extracting logic. [cite: 463] With the introduction of runes, these use cases have diminished. [cite: 463]\n\n* **Extracting logic**: Runes' universal reactivity is now preferred, allowing you to use runes outside of components (in `.svelte.js` or `.svelte.ts` files). [cite: 463]\n* **Creating shared state**: You can create a `$state` object with the necessary values and manipulate it directly. [cite: 464]\n\nExample of shared state with `$state` in `.svelte.js`:\n```ts\n/// file: state.svelte.js\nexport const userState = $state({\n\tname: 'name',\n\t/* ... */\n});\n```\nThen in `App.svelte`:\n```svelte\n<!file: App.svelte>\n<script>\n\timport { userState } from './state.svelte.js';\n</script>\n\n<p>User name: {userState.name}</p>\n<button onclick={() => {\n\tuserState.name = 'new name';\n}}>\n\tchange name\n</button>\n```\n\nStores remain a good solution for complex asynchronous data streams or when more manual control over value updates and change listening is needed. [cite: 466] They are also useful for those familiar with RxJs. [cite: 467]\n\n**`svelte/store` module**: This module provides functions for creating stores:\n* **`writable`**: Creates a store whose values can be set from outside components. [cite: 470] It includes `set` (to set a new value) and `update` (to update the value using a callback) methods. [cite: 471, 474] If a function is provided as a second argument, it's called when the subscriber count goes from zero to one, and it must return a `stop` function that is called when the count goes from one to zero. [cite: 477, 479] Writable values are lost on page refresh unless explicitly synced (e.g., to `localStorage`). [cite: 482, 483]\n* **`readable`**: Creates a store whose value cannot be set from outside. [cite: 484] Its second argument behaves like `writable`'s second argument. [cite: 484]\n* **`derived`**: Derives a store from one or more other stores. [cite: 487] The callback runs on initial subscription and whenever store dependencies change. [cite: 488] It can be synchronous or asynchronous (using `set` and `update` arguments in the callback). [cite: 492] A third argument can provide an initial value. [cite: 493]\n* **`readonly`**: Makes an existing store readonly. [cite: 506]\n* **`get`**: Retrieves the current value of a store without subscribing to it. [cite: 509, 511]"}
{"question":"What is the Svelte Store contract?","answer":"You can create custom stores in Svelte without relying on `svelte/store` by adhering to the *store contract*: [cite: 512]\n\n1.  **`.subscribe` method**: A store must have a `.subscribe` method that accepts a subscription function as its argument. [cite: 512] This subscription function must be called immediately and synchronously with the store's current value upon calling `.subscribe`. [cite: 513] All active subscription functions must then be called synchronously whenever the store's value changes. [cite: 514]\n2.  **Unsubscribe function**: The `.subscribe` method must return an unsubscribe function. Calling this function must stop its corresponding subscription, preventing further calls to its subscription function. [cite: 515]\n3.  **Optional `.set` method**: A store *may optionally* include a `.set` method. [cite: 516] If present, it must accept a new value for the store and synchronously call all active subscription functions. [cite: 516] Such a store is known as a *writable store*. [cite: 516]\n\nFor interoperability with RxJS Observables, the `.subscribe` method can also return an object with an `.unsubscribe` method, rather than the function directly. [cite: 517] However, if `.subscribe` does not synchronously call the subscription (which is not required by the Observable spec), Svelte will consider the store's value as `undefined` until it does. [cite: 518]"}
{"question":"How does context work in Svelte?","answer":"Context in Svelte allows components to access values provided by their parent components without needing to pass them down through many layers of intermediate components (known as 'prop-drilling'). [cite: 519]\n\nThe parent component sets a context value using `setContext(key, value)`: [cite: 520]\n```svelte\n<!file: Parent.svelte>\n<script>\n\timport { setContext } from 'svelte';\n\n\tsetContext('my-context', 'hello from Parent.svelte');\n</script>\n```\nAnd the child component retrieves it using `getContext(key)`: [cite: 521]\n```svelte\n<!file: Child.svelte>\n<script>\n\timport { getContext } from 'svelte';\n\n\tconst message = getContext('my-context');\n</script>\n\n<h1>{message}, inside Child.svelte</h1>\n```\nThis is especially useful when the parent component is not directly aware of the child, but renders it as part of a `children` snippet. [cite: 522] The `key` and the context value itself can be any JavaScript value. [cite: 522]\n\nSvelte also exposes `hasContext` (to check if a key exists) and `getAllContexts` (to retrieve the entire context map). [cite: 523]\n\n**Using context with state**: You can store reactive state in context: [cite: 524]\n```svelte\n<script>\n\timport { setContext } from 'svelte';\n\timport Child from './Child.svelte';\n\n\tlet counter = $state({\n\t\tcount: 0\n\t});\n\n\tsetContext('counter', counter);\n</script>\n\n<button onclick={() => counter.count += 1}>\n\tincrement\n</button>\n\n<Child />\n<Child />\n<Child />\n```\nHowever, if you *reassign* the state object (e.g., `counter = { count: 0 }`) instead of mutating its properties (e.g., `counter.count = 0`), you will break the reactivity link. Svelte will warn you if this happens. [cite: 526]\n\n**Type-safe context**: A common pattern is to wrap `setContext` and `getContext` calls in helper functions to maintain type safety. [cite: 527, 528]\n\n**Replacing global state**: Context helps solve the problem of shared global state being mutated during server-side rendering and potentially affecting subsequent requests, as context is not shared between requests. [cite: 532, 533]"}
{"question":"What are lifecycle hooks in Svelte 5?","answer":"In Svelte 5, the component lifecycle is simplified to only its creation and destruction. [cite: 536] Updates to state are handled by (render) effects, which are the smallest unit of change, rather than affecting the component as a whole. [cite: 538, 539] Consequently, there are no \"before update\" or \"after update\" hooks in Svelte 5. [cite: 540]\n\n**`onMount`**: This function schedules a callback to run as soon as the component has been mounted to the DOM. [cite: 541] It must be called during the component's initialisation and does not run during server-side rendering. [cite: 542, 543]\n\nExample:\n```svelte\n<script>\n\timport { onMount } from 'svelte';\n\tonMount(() => {\n\t\tconsole.log('the component has mounted');\n\t});\n</script>\n```\nIf `onMount` returns a function, that function will be called when the component is unmounted. [cite: 544]\n\n**`onDestroy`**: This schedules a callback to run immediately before the component is unmounted. [cite: 546] Unlike `onMount`, `beforeUpdate`, and `afterUpdate`, `onDestroy` *does* run inside a server-side component. [cite: 547]\n\nExample:\n```svelte\n<script>\n\timport { onDestroy } from 'svelte';\n\tonDestroy(() => {\n\t\tconsole.log('the component is being destroyed');\n\t});\n</script>\n```\n\n**`tick`**: While there's no direct \"after update\" hook, `tick` returns a promise that resolves once any pending state changes have been applied, or in the next microtask if there are none. [cite: 549, 550] This can be used to ensure the UI is updated before continuing. [cite: 549]\n\nExample using `tick` with `$effect.pre`:\n```svelte\n<script>\n\timport { tick } from 'svelte';\n\n\t$effect.pre(() => {\n\t\tconsole.log('the component is about to update');\n\t\ttick().then(() => {\n\t\t\t\tconsole.log('the component just updated');\n\t\t});\n\t});\n</script>\n```\n\n**Deprecated: `beforeUpdate` / `afterUpdate`**: These Svelte 4 hooks ran before and after component updates. [cite: 552] They are shimmed for backward compatibility in Svelte 5 but are not available in components using runes. [cite: 553] Instead, `$effect.pre` and `$effect` should be used for more granular control over reactivity. [cite: 558, 559]"}
{"question":"How do you imperatively create and manage Svelte components in Svelte 5?","answer":"In Svelte 5, every Svelte application begins by imperatively creating a root component. [cite: 562] On the client, this component is mounted to a specific element, while on the server, a string of HTML is returned for rendering. [cite: 563, 564]\n\n**`mount`**: This function instantiates a component and mounts it to the specified target element. [cite: 565]\n\nExample:\n```js\n// @errors: 2322\nimport { mount } from 'svelte';\nimport App from './App.svelte';\n\nconst app = mount(App, {\n\ttarget: document.querySelector('#app'),\n\tprops: { some: 'property' }\n});\n```\nYou can mount multiple components on a page, including from within your application. [cite: 567] Unlike `new App(...)` in Svelte 4, effects (including `onMount` callbacks and action functions) do not run during `mount`. [cite: 568] To force pending effects to run synchronously (e.g., in a test), use `flushSync()`. [cite: 569]\n\n**`unmount`**: This function unmounts a component that was previously created with `mount` or `hydrate`. [cite: 570] If `options.outro` is `true`, transitions will play before the component is removed from the DOM. [cite: 570]\n\nExample:\n```js\nimport { mount, unmount } from 'svelte';\nimport App from './App.svelte';\n\nconst app = mount(App, { target: document.body });\n\n// later\nunmount(app, { outro: true });\n```\n`unmount` returns a `Promise` that resolves after transitions complete (if `options.outro` is `true`) or immediately otherwise. [cite: 573]\n\n**`render`**: This function is only available on the server when compiling with the `server` option. [cite: 574] It takes a component and returns an object with `body` and `head` properties, which you can use to populate the HTML when server-rendering your app. [cite: 574]\n\nExample:\n```js\n// @errors: 2724 2305 2307\nimport { render } from 'svelte/server';\nimport App from './App.svelte';\n\nconst result = render(App, {\n\tprops: { some: 'property' }\n});\nresult.body; // HTML for somewhere in this <body> tag\nresult.head; // HTML for somewhere in this <head> tag\n```\n\n**`hydrate`**: Similar to `mount`, `hydrate` reuses existing HTML rendered by Svelte's SSR output (from the `render` function) within the target element and makes it interactive. [cite: 577]\n\nExample:\n```js\n// @errors: 2322\nimport { hydrate } from 'svelte';\nimport App from './App.svelte';\n\nconst app = hydrate(App, {\n\ttarget: document.querySelector('#app'),\n\tprops: { some: 'property' }\n});\n```\nAs with `mount`, effects do not run during `hydrate`; use `flushSync()` immediately afterward if needed. [cite: 579]"}
{"question":"How do you test Svelte applications?","answer":"Testing in Svelte helps ensure code quality and prevent regressions, and Svelte is unopinionated about the testing framework used. [cite: 580, 581] You can write unit, integration, and end-to-end tests with tools like Vitest, Jasmine, Cypress, and Playwright. [cite: 582]\n\n**Unit and Integration Testing with Vitest**: Unit tests focus on isolated code parts, while integration tests check how parts of your application work together. [cite: 583, 584] For Vite (including SvelteKit) users, Vitest is recommended. [cite: 585]\n\nTo get started with Vitest:\n1.  Install Vitest: `npm install -D vitest` [cite: 585]\n2.  Adjust `vite.config.js` to tell Vitest to use browser entry points. [cite: 586]\n\nExample of a unit test for a `.svelte.js` file: [cite: 588, 589]\n```js\n/// file: multiplier.svelte.test.js\nimport { flushSync } from 'svelte';\nimport { expect, test } from 'vitest';\nimport { multiplier } from './multiplier.svelte.js';\n\ntest('Multiplier', () => {\n\tlet double = multiplier(0, 2);\n\n\texpect(double.value).toEqual(0);\n\n\tdouble.set(5);\n\n\texpect(double.value).toEqual(10);\n});\n```\nYou can use runes directly in your test files if the filename includes `.svelte` (e.g., `.svelte.test.js`). [cite: 592, 593, 594] If the code being tested uses effects, wrap the test inside `$effect.root` and use `flushSync()` to execute pending effects synchronously. [cite: 596, 598]\n\n**Component Testing**: Components can be tested in isolation using Vitest. [cite: 600]\n1.  Install `jsdom`: `npm install -D jsdom` [cite: 600]\n2.  Adjust `vite.config.js` to set the test environment to `jsdom`. [cite: 601]\n\nAfter setup, you can import the component, interact with it programmatically, and write expectations. [cite: 604] While straightforward, this can be brittle due to component structure changes. [cite: 606] Libraries like `@testing-library/svelte` can streamline component tests by providing higher-level utilities. [cite: 606, 607, 608, 609] For tests involving two-way bindings, context, or snippet props, creating a wrapper component is recommended. [cite: 610]\n\n**End-to-End (E2E) Tests with Playwright**: E2E tests validate the full application from a user's perspective. [cite: 611] Playwright is a common choice, and it's included in SvelteKit's setup CLI (`npx sv create`). [cite: 612, 613]\n\nTo configure Playwright:\n1.  Install Playwright (if not using `npx sv create`). [cite: 613]\n2.  Adjust `playwright.config.js` to define the `webServer` command and port for your application. [cite: 615]\n\nE2E tests interact directly with the DOM and do not need Svelte-specific knowledge. [cite: 617]\n\nExample E2E test: [cite: 618, 619]\n```js\n/// file: tests/hello-world.spec.js\nimport { expect, test } from '@playwright/test';\n\ntest('home page has expected h1', async ({ page }) => {\n\tawait page.goto('/');\n\tawait expect(page.locator('h1')).toBeVisible();\n});\n```"}
{"question":"How do you use TypeScript with Svelte?","answer":"You can use TypeScript within Svelte components by adding `lang=\"ts\"` to your script tags. [cite: 620, 622] IDE extensions, such as the Svelte VS Code extension, and `svelte-check` will help catch errors. [cite: 621]\n\nExample:\n```svelte\n<script lang=\"ts\">\n\tlet name: string = 'world';\n\tfunction greet(name: string) {\n\t\talert(`Hello, ${name}!`);\n\t}\n</script>\n\n<button onclick={(e: Event) => greet(e.target.innerText)}>\n\t{name as string}\n</button>\n```\nThis enables TypeScript's *type-only* features (like type annotations and interface declarations), which disappear during transpilation to JavaScript. [cite: 623, 624] Features requiring TypeScript to output actual code (e.g., enums, `private`/`protected`/`public` modifiers with initializers in constructors, or non-standard ECMAScript features) are *not* natively supported within Svelte's compiler and require a script preprocessor. [cite: 625, 626]\n\n**Preprocessor Setup**: To use non-type-only TypeScript features, you need a preprocessor. [cite: 627] For SvelteKit or Vite, the easiest way is to scaffold a new project with TypeScript support using `npx sv create` or `npm create vite@latest` (selecting `svelte-ts`). [cite: 628, 629, 631] This will add `vitePreprocess()` to your `svelte.config.js`. [cite: 630] For other build tools like Rollup or Webpack, install their respective Svelte plugins, `typescript`, and `svelte-preprocess`, then add the preprocessor to the plugin configuration. [cite: 633, 634]\n\n**`tsconfig.json` settings**: Ensure your `tsconfig.json` is correctly configured: [cite: 636]\n* `target` should be at least `ES2022` (or `ES2015` with `useDefineForClassFields`) to ensure rune declarations on class fields are handled correctly. [cite: 637]\n* `verbatimModuleSyntax` should be `true` to keep imports as-is. [cite: 637]\n* `isolatedModules` should be `true` because Svelte's compiler and tools like Vite process files in isolation, and certain TypeScript features require cross-file analysis. [cite: 638, 639]\n\n**Typing `$props`**: Type `$props` like a regular object with specific properties. [cite: 641]\n\n**Generic `$props`**: Components can declare generic relationships between properties using the `generics` attribute on the `script` tag. [cite: 642, 643, 644, 645]\n\n**Typing Wrapper Components**: For components wrapping native elements, use or extend interfaces from `svelte/elements` (e.g., `HTMLButtonAttributes` or `SvelteHTMLElements['div']`) to expose underlying element attributes. [cite: 648, 649, 650, 651, 652]\n\n**Typing `$state`**: `$state` can be typed like any other variable. [cite: 653] If `$state` is initialized without a value, its type will include `undefined`. [cite: 654] An `as` cast can be used if the variable is guaranteed to be defined before use, especially in classes. [cite: 656, 657]\n\n**The `Component` type**: Svelte components are of type `Component`. [cite: 658] This type can be used with dynamic components to restrict the kinds of components that can be passed. [cite: 659, 660] (Note: In Svelte 4, components were of type `SvelteComponent`). [cite: 661] `ComponentProps` can extract properties from a component. [cite: 661] To declare a variable expecting a component's constructor or instance type, use `typeof MyComponent` or `MyComponent` respectively. [cite: 664]\n\n**Enhancing built-in DOM types**: You can extend Svelte's HTML DOM types in a `d.ts` file using the `svelteHTML` namespace or by augmenting the `svelte/elements` module. [cite: 669, 670, 671, 672, 673, 674, 675, 676, 677] This is useful for experimental attributes or custom events from actions."}
{"question":"How do you compile Svelte components to custom elements?","answer":"Svelte components can be compiled into custom elements (also known as web components) by setting the `customElement: true` compiler option. [cite: 678] You also need to specify a tag name for the component using the `<svelte:options>` element. [cite: 679]\n\nExample:\n```svelte\n<svelte:options customElement=\"my-element\" />\n\n<script>\n\tlet { name = 'world' } = $props();\n</script>\n\n<h1>Hello {name}!</h1>\n<slot />\n```\nInner components that you don't wish to expose as custom elements can omit the tag name and be used like regular Svelte components. [cite: 681] Consumers can still define the custom element later using the static `element` property, which holds the custom element constructor. [cite: 681, 682]\n\nOnce defined, a custom element can be used as a regular DOM element. [cite: 683] Any [props](docs/svelte/basic-markup#Component-props) are exposed as properties of the DOM element, and can also be read/written as attributes. [cite: 684, 685, 686] All properties must be explicitly listed in `$props()` for Svelte to expose them as properties on the DOM element. [cite: 687]\n\n**Component Lifecycle**: Custom elements from Svelte components use a wrapper approach, meaning the inner Svelte component is unaware it's a custom element. [cite: 688, 689] The inner component is created in the next tick after `connectedCallback` is invoked. [cite: 691] Properties assigned before DOM insertion are temporarily saved and set on component creation. [cite: 692] Exported functions are only available after the element has mounted, but can be accessed earlier by using the `extend` option. [cite: 693, 694] Shadow DOM updates occur in the next tick, allowing batching and preventing re-unmounting during temporary DOM moves. [cite: 696] The inner Svelte component is destroyed in the next tick after `disconnectedCallback`. [cite: 697]\n\n**Component Options**: When constructing a custom element, you can configure it via the `customElement` object within `<svelte:options>`. [cite: 698] This object can have:\n* `tag: string`: An optional tag name. If set, the custom element will be defined with the `customElements` registry upon import. [cite: 699, 700]\n* `shadow`: Optional; `\"none\"` skips shadow root creation (styles are no longer encapsulated, and slots cannot be used). [cite: 701]\n* `props`: Optional; modifies property behaviors. [cite: 702]\n    * `attribute: string`: Customizes the HTML attribute name for the prop. [cite: 703, 704]\n    * `reflect: boolean`: If `true`, updated prop values reflect back to the DOM. [cite: 705]\n    * `type: 'String' | 'Boolean' | 'Number' | 'Array' | 'Object'`: Specifies the type for attribute-to-prop conversion and reflection. [cite: 706, 707]\n* `extend`: An optional function that receives the generated custom element class and returns a custom element class. [cite: 709, 710] This is useful for specific lifecycle requirements or enhancing the class (e.g., for `ElementInternals`). [cite: 711, 712, 713, 714]\n\n**Caveats and Limitations**: Custom elements are useful for non-Svelte apps but have differences: [cite: 715]\n* Styles are *encapsulated* (unless `shadow: \"none\"`), meaning non-component styles won't apply to the custom element. [cite: 716]\n* Styles are inlined as JavaScript strings. [cite: 716]\n* Generally not suitable for SSR as shadow DOM is invisible until JS loads. [cite: 716]\n* Slotted content renders *eagerly* in the DOM (always created, even in `{#if}` blocks), unlike Svelte's lazy rendering. [cite: 717, 718]\n* The deprecated `let:` directive has no effect. [cite: 718]\n* Polyfills are needed for older browsers. [cite: 718]\n* Svelte's context feature works between regular Svelte components within a custom element, but not across custom elements. [cite: 719, 720]\n* Avoid properties or attributes starting with `on` as they will be interpreted as event listeners. [cite: 721]"}
{"question":"What are the key changes in Svelte 5 for migration from Svelte 4?","answer":"Svelte 5 brings significant changes to its syntax and reactivity system, introducing the runes API. [cite: 775] While a different approach, Svelte 5 maintains backward compatibility with Svelte 4 syntax, allowing for a mixed codebase during incremental migration. [cite: 779] A migration script (`npx sv migrate svelte-5`) is available to automate many steps. [cite: 780, 863]\n\n**Reactivity Syntax Changes**: [cite: 782]\n* **`let` â†’ `$state`**: In Svelte 4, top-level `let` declarations were implicitly reactive. In Svelte 5, reactivity is explicit via the `$state` rune. [cite: 784, 785] The variable remains a direct value (not a wrapper), and reads/writes are direct. [cite: 786] This allows consistent reactivity API outside components. [cite: 790]\n* **`$:` â†’ `$derived`/`$effect`**: Svelte 4's `$:` statements were used for derivations and side effects. In Svelte 5, `$derived.by(() => ...)` is for derivations, and `$effect(() => ...)` is for side effects. [cite: 792, 795] `$derived` values are direct. [cite: 794] The timing of `$effect` differs from `$:` statements. [cite: 797] This change aims for clearer intent and better reasoning about reactivity, fixing issues like stale values and unreliable dependency tracking. [cite: 798, 800, 801, 802, 806]\n* **`export let` â†’ `$props`**: Svelte 4 used `export let` for component properties. Svelte 5 declares all properties through destructuring the `$props` rune. [cite: 807, 809] This simplifies handling renaming, rest props, and passing all props, eliminating the need for `export { klass as class }`, `$$restProps`, and `$$props`. [cite: 810, 811, 815]\n\n**Event Changes**: [cite: 816]\n* **`on:` directive â†’ event attributes**: Svelte 4 used `on:click`. Svelte 5 uses event attributes like `onclick`, which are treated as normal properties. [cite: 817] Shorthand syntax is available. [cite: 818] Named handler functions are encouraged to be more descriptive. [cite: 819]\n* **Component events (`createEventDispatcher`) â†’ callback props**: `createEventDispatcher` is deprecated. Components should now accept callback props. [cite: 820, 822] Forwards events from elements by accepting an `onclick` callback prop. [cite: 826] Event handlers can be spread along with other props. [cite: 827]\n* **Event modifiers**: Svelte 4's event modifiers (e.g., `|once`, `|preventDefault`) are no longer applicable to event attributes. [cite: 828] Performing `event.preventDefault()` directly within the handler is now preferred. [cite: 829] Wrapper functions can be created for custom modifiers. [cite: 830] `capture`, `passive`, and `nonpassive` modifiers are exceptions and apply to the event name (e.g., `onclickcapture`). [cite: 832, 833]\n* **Multiple event handlers**: Svelte 4 allowed multiple listeners for the same event (e.g., `on:click={one} on:click={two}`). This is no longer allowed in Svelte 5; instead, combine logic in a single handler. [cite: 836]\n\n**Snippets instead of Slots**: [cite: 846]\n* Svelte 4 used `<slot>` for passing content, which is now deprecated. Svelte 5 uses snippets (`{#snippet ...}`) and render tags (`{@render ...}`). [cite: 846, 1784]\n* Default content is now handled by the `children` prop and `{@render children()}`. [cite: 850]\n* Multiple content placeholders use named props and `{@render ...}`. [cite: 852]\n* Passing data back up from slots is now done via snippet parameters. [cite: 854]\n\n**Migration script**: The `npx sv migrate svelte-5` script automates many of these changes. [cite: 863] It converts `let` to `$state`, `on:click` to `onclick`, slot creations to render tags, and more. [cite: 864] The script might convert some `$:` statements to a `run` function (from `svelte/legacy`) if it cannot reliably migrate to `$derived` or `$effect`. [cite: 867]\n\n**Components are no longer classes**: In Svelte 3 and 4, components were classes. In Svelte 5, they are functions. [cite: 875] Manual instantiation now uses `mount` or `hydrate` (from `svelte`). [cite: 876, 877] `mount` and `hydrate` return an object with component exports. [cite: 881] `$on` is replaced by passing events via the `events` property in options, `$set` by manipulating a `$state` props object, and `$destroy` by `unmount`. [cite: 884, 887, 891] `createClassComponent` or `asClassComponent` (from `svelte/legacy`) can be used as a stop-gap. [cite: 893] The `compatibility.componentApi` compiler option can enable Svelte 4 class API. [cite: 896]\n\n**Server API changes**: Components no longer have a `render` method directly. Instead, `render` from `svelte/server` is used. [cite: 899, 900, 902] CSS is no longer returned by default from `render` unless `css` compiler option is set to `'injected'`. [cite: 904, 905]\n\n**Component typing changes**: `SvelteComponent` is deprecated in favor of the new `Component` type. [cite: 907] `ComponentEvents` and `ComponentType` are obsolete. [cite: 910]\n\n**`<svelte:component>` is no longer necessary**: Components are dynamic by default in Svelte 5. [cite: 912] `<svelte:component>` is no longer needed to re-render when the component's value changes. [cite: 913]\n\n**Whitespace handling changed**: Svelte 5 simplifies whitespace rules, collapsing whitespace between nodes and removing it at tag start/end, with exceptions for `pre` tags. [cite: 917, 918] `preserveWhitespace` option can disable trimming. [cite: 919]\n\n**Modern browser required**: Svelte 5 requires a modern browser due to its use of `Proxies`, `ResizeObserver`, and standard event handling. [cite: 920]\n\n**Changes to compiler options**: Several compiler options have been removed, repurposed, or had their default values changed. [cite: 921, 922, 923]\n\n**`children` prop is reserved**: The `children` prop name is reserved for implicitly passed content within component tags. [cite: 924]\n\n**Breaking changes in runes mode**: Bindings to component exports are disallowed, requiring `bind:this` instead. [cite: 926, 927] Bindings need to be explicitly defined with `$bindable()`. [cite: 931] The `accessors` and `immutable` options are ignored. [cite: 934, 941] Classes are no longer \"auto-reactive\"; reactivity needs to be explicit with `$state` fields. [cite: 944, 945] Touch and wheel events are passive by default. [cite: 947] Attribute/prop syntax is stricter, requiring quotes for concatenated values. [cite: 950] HTML structure is stricter, throwing compiler errors for invalid HTML. [cite: 953]\n\n**Other breaking changes**: Include stricter `@const` assignment validation, scoped `:is(...)` and `:where(...)` selectors, non-deterministic CSS hash position, and renamed error/warning codes. [cite: 954, 955, 959, 963] Reduced number of namespaces, `beforeUpdate`/`afterUpdate` changes, and `contenteditable` behavior changes. [cite: 965, 967, 971] `null` and `undefined` become empty strings. [cite: 974] `bind:files` is two-way and only accepts `null`, `undefined`, or `FileList`. [cite: 976] Bindings now react to form resets. [cite: 978] `walk` is no longer exported from `svelte/compiler`. [cite: 980] Content inside `svelte:options` is forbidden. [cite: 983] `<slot>` elements in declarative shadow roots are preserved. [cite: 985] `<svelte:element>` tag must be an expression. [cite: 987] `mount` plays transitions by default. [cite: 990] `<img> src={...}` and `{@html ...}` hydration mismatches are not repaired. [cite: 992] Hydration works differently, using comments. [cite: 998] `onevent` attributes are delegated. [cite: 1000] `--style-props` uses a different element (`<svelte-css-wrapper>`). [cite: 1002]"}
{"question":"What are the common Svelte compiler errors?","answer":"Svelte compiler errors indicate issues that prevent the code from compiling correctly. Common errors include:\n\n* **`animation_duplicate`**: An element can only have one `animate:` directive. [cite: 1474]\n* **`animation_invalid_placement`**: An element using `animate:` must be the only child of a keyed `{#each ...}` block. [cite: 1475]\n* **`attribute_duplicate`**: Attributes need to be unique. [cite: 1476]\n* **`attribute_invalid_event_handler`**: Event attribute must be a JavaScript expression, not a string. [cite: 1477]\n* **`attribute_unquoted_sequence`**: Attribute values containing `[...]` must be enclosed in quotes, unless the value only contains the expression. [cite: 1477]\n* **`bind_invalid_expression`**: Can only bind to an Identifier or MemberExpression or a `{get, set}` pair. [cite: 1478]\n* **`bind_invalid_name`**: `%name%` is not a valid binding. [cite: 1478]\n* **`bindable_invalid_location`**: `$bindable()` can only be used inside a `$props()` declaration. [cite: 1479]\n* **`block_unclosed`**: Block was left open. [cite: 1479]\n* **`block_unexpected_close`**: Unexpected block closing tag. [cite: 1479]\n* **`const_tag_invalid_expression`**: `{@const ...}` must consist of a single variable declaration. [cite: 1479]\n* **`const_tag_invalid_placement`**: `{@const}` must be an immediate child of certain blocks or components. [cite: 1479]\n* **`constant_assignment`**: Cannot assign to a constant. [cite: 1479]\n* **`css_global_invalid_placement`**: `:global(...)` can only be at the start or end of a selector sequence. [cite: 1480]\n* **`derived_invalid_export`**: Cannot export derived state from a module; export a function returning its value instead. [cite: 1481]\n* **`each_item_invalid_assignment`**: Cannot reassign or bind to `each` block argument in runes mode; use array and index variables instead. [cite: 1482]\n* **`effect_invalid_placement`**: `$effect()` can only be used as an expression statement. [cite: 1484]\n* **`element_invalid_closing_tag`**: Attempted to close an element that was not open. [cite: 1484]\n* **`element_unclosed`**: Element was left open. [cite: 1484]\n* **`expected_token`**: Expected token `%token%`. [cite: 1486]\n* **`global_reference_invalid`**: `%name%` is an illegal variable name; use `globalThis.%name%` to reference a global. [cite: 1487]\n* **`host_invalid_placement`**: `$host()` can only be used inside custom element component instances. [cite: 1487]\n* **`import_svelte_internal_forbidden`**: Imports of `svelte/internal/*` are forbidden. [cite: 1488]\n* **`js_parse_error`**: JavaScript parse error. [cite: 1489]\n* **`legacy_export_invalid`**: Cannot use `export let` in runes mode; use `$props()` instead. [cite: 1489]\n* **`legacy_reactive_statement_invalid`**: `$:` is not allowed in runes mode; use `$derived` or `$effect` instead. [cite: 1489]\n* **`mixed_event_handler_syntaxes`**: Mixing old (`on:`) and new (`on...`) event handling syntaxes is not allowed. [cite: 1490]\n* **`module_illegal_default_export`**: A component cannot have a default export. [cite: 1491]\n* **`node_invalid_placement`**: HTML element placement rules violated, causing browser to repair HTML which breaks Svelte's assumptions. [cite: 1492, 1493]\n* **`props_id_invalid_placement`**: `$props.id()` can only be used at the top level of components as a variable declaration initializer. [cite: 1494]\n* **`props_invalid_identifier`**: `$props()` can only be used with an object destructuring pattern. [cite: 1494]\n* **`props_invalid_pattern`**: `$props()` assignment must not contain nested properties or computed keys. [cite: 1495]\n* **`props_invalid_placement`**: `$props()` can only be used at the top level of components as a variable declaration initializer. [cite: 1495]\n* **`render_tag_invalid_expression`**: `{@render ...}` tags can only contain call expressions. [cite: 1495]\n* **`rune_invalid_arguments`**: Rune cannot be called with arguments. [cite: 1495]\n* **`rune_missing_parentheses`**: Cannot use rune without parentheses. [cite: 1496]\n* **`runes_mode_invalid_import`**: Element cannot be used in runes mode. [cite: 1496]\n* **`script_duplicate`**: A component can only have one top-level `<script>` element and/or a single top-level `<script module>` element. [cite: 1496]\n* **`slot_attribute_invalid_placement`**: Element with `slot='...'` attribute must be a child of a component or a descendant of a custom element. [cite: 1497]\n* **`slot_snippet_conflict`**: Cannot use `<slot>` syntax and `{@render ...}` tags in the same component. [cite: 1498]\n* **`snippet_conflict`**: Cannot use explicit children snippet and implicit children content. [cite: 1499]\n* **`snippet_invalid_export`**: An exported snippet can only reference things declared in a `<script module>`, or other exportable snippets. [cite: 1500]\n* **`snippet_invalid_rest_parameter`**: Snippets do not support rest parameters; use an array instead. [cite: 1502]\n* **`state_invalid_export`**: Cannot export state from a module if it is reassigned. [cite: 1503]\n* **`state_invalid_placement`**: `%rune%(...)` can only be used as a variable declaration initializer or a class field. [cite: 1503]\n* **`store_invalid_scoped_subscription`**: Cannot subscribe to stores not declared at the top level of the component. [cite: 1503]\n* **`store_invalid_subscription_module`**: Cannot reference store value outside a `.svelte` file. [cite: 1504]\n* **`style_directive_invalid_modifier`**: `style:` directive can only use the `important` modifier. [cite: 1504]\n* **`svelte_meta_invalid_placement`**: `<svelte:...>` tags cannot be inside elements or blocks. [cite: 1505]\n* **`svelte_options_invalid_customelement`**: `customElement` must be a string literal or an object. [cite: 1506]\n* **`svelte_self_invalid_placement`**: `<svelte:self>` components can only exist inside `{#if}` blocks, `{#each}` blocks, `{#snippet}` blocks or slots passed to components. [cite: 1507]\n* **`typescript_invalid_feature`**: TypeScript language features are not natively supported and require a preprocessor. [cite: 1509]\n* **`unexpected_eof`**: Unexpected end of input. [cite: 1510]\n* **`void_element_invalid_content`**: Void elements cannot have children or closing tags. [cite: 1510]"}
{"question":"What are common Svelte compiler warnings?","answer":"Svelte compiler warnings alert you to potential issues or mistakes in your code that don't prevent compilation but might lead to unexpected behavior or accessibility problems. You can disable specific warnings by adding a `` comment above the offending line. [cite: 1511, 1512, 1513]\n\nCommon compiler warnings include:\n\n**Accessibility Warnings (`a11y_...`)**:\n* **`a11y_accesskey`**: Avoid using `accesskey` attributes due to accessibility complications. [cite: 1515, 1517]\n* **`a11y_aria_activedescendant_has_tabindex`**: Elements with `aria-activedescendant` should have a `tabindex` value. [cite: 1518]\n* **`a11y_aria_attributes`**: Certain reserved DOM elements (e.g., `meta`, `script`) should not have `aria-*` attributes. [cite: 1519, 1521]\n* **`a11y_autofocus`**: Avoid using `autofocus` on elements as it can cause usability issues. [cite: 1522, 1523]\n* **`a11y_click_events_have_key_events`**: Visible, non-interactive elements with an `onclick` event must also have a keyboard event handler (e.g., `onkeyup` or `onkeydown`) and be focusable via `tabindex`. [cite: 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1533]\n* **`a11y_consider_explicit_label`**: Buttons and links should contain text or have an `aria-label` or `aria-labelledby` attribute. [cite: 1533]\n* **`a11y_distracting_elements`**: Avoid visually distracting elements like `<marquee>` and `<blink>`. [cite: 1534, 1535, 1536]\n* **`a11y_figcaption_parent`**: `<figcaption>` must be an immediate child of `<figure>`. [cite: 1537]\n* **`a11y_hidden`**: Certain DOM elements useful for screen reader navigation (e.g., `h2`) should not be hidden with `aria-hidden`. [cite: 1538]\n* **`a11y_img_redundant_alt`**: `<img>` alt text should not contain words like \"image\", \"picture\", or \"photo\" as screen readers already announce them as images. [cite: 1539, 1540, 1541, 1542, 1543]\n* **`a11y_incorrect_aria_attribute_type`**: Enforce correct value types for ARIA attributes (e.g., `aria-hidden` should be boolean). [cite: 1544]\n* **`a11y_interactive_supports_focus`**: Elements with interactive roles (e.g., `button`) and handlers must be focusable (have `tabindex`). [cite: 1546]\n* **`a11y_invalid_attribute`**: Attributes important for accessibility (e.g., `href`) must have valid values (not empty, `'#'`, or `javascript:`). [cite: 1548, 1549]\n* **`a11y_label_has_associated_control`**: Form labels must be associated with a control, either by wrapping it or using a `for` attribute. [cite: 1550, 1553]\n* **`a11y_media_has_caption`**: `<video>` elements (unless `muted`) must have a `<track kind=\"captions\">` for accessibility. [cite: 1554, 1558, 1559]\n* **`a11y_misplaced_role`**: Reserved DOM elements (e.g., `meta`, `style`) should not have `role` attributes. [cite: 1560, 1562]\n* **`a11y_misplaced_scope`**: The `scope` attribute should only be used on `<th>` elements. [cite: 1563]\n* **`a11y_missing_attribute`**: Enforces required attributes for accessibility on elements like `<a>` (href), `<img>` (alt), `<html>` (lang), etc. [cite: 1564]\n* **`a11y_missing_content`**: Heading elements and anchors should contain accessible content. [cite: 1565]\n* **`a11y_mouse_events_have_key_events`**: `onmouseover`/`onmouseout` should be accompanied by `onfocus`/`onblur` respectively. [cite: 1566, 1567]\n* **`a11y_no_abstract_role`**: Abstract ARIA roles are forbidden. [cite: 1567]\n* **`a11y_no_interactive_element_to_noninteractive_role`**: Interactive elements (e.g., `<textarea>`) cannot have non-interactive ARIA roles. [cite: 1568, 1569]\n* **`a11y_no_noninteractive_element_interactions`**: Non-interactive elements (e.g., `<li>`, `<div>` with `role=\"listitem\"`) should not have mouse or keyboard event listeners. [cite: 1570, 1571, 1572]\n* **`a11y_no_noninteractive_element_to_interactive_role`**: Non-interactive elements (e.g., `<h3>`) cannot have interactive ARIA roles. [cite: 1573, 1574]\n* **`a11y_no_noninteractive_tabindex`**: Non-interactive elements cannot have a non-negative `tabIndex` value. [cite: 1575]\n* **`a11y_no_redundant_roles`**: Avoid redundant ARIA roles on HTML elements that already have default roles (e.g., `<button role=\"button\">`). [cite: 1576, 1577]\n* **`a11y_no_static_element_interactions`**: Elements like `<div>` with interactive handlers (e.g., `click`) must have an ARIA role. [cite: 1578]\n* **`a11y_positive_tabindex`**: Avoid `tabindex` values greater than zero as they disrupt expected tab order. [cite: 1579, 1580]\n* **`a11y_role_has_required_aria_props`**: Elements with ARIA roles must have all required attributes for that role. [cite: 1581]\n* **`a11y_role_supports_aria_props`**: Elements with explicit or implicit roles should only contain `aria-*` properties supported by that role. [cite: 1582, 1585, 1586]\n* **`a11y_unknown_aria_attribute`**: Only known ARIA attributes are allowed. [cite: 1590]\n* **`a11y_unknown_role`**: Elements with ARIA roles must use a valid, non-abstract ARIA role. [cite: 1593]\n\n**Other Warnings**:\n* **`attribute_avoid_is`**: The \"is\" attribute is not cross-browser compatible. [cite: 1594]\n* **`attribute_global_event_reference`**: Warns about referencing `globalThis.%name%`, suggesting a forgotten variable declaration. [cite: 1595]\n* **`attribute_illegal_colon`**: Attributes should not contain `:` to avoid ambiguity with directives. [cite: 1596]\n* **`attribute_invalid_property_name`**: Warns about invalid HTML attributes and suggests correct ones. [cite: 1597]\n* **`attribute_quoted`**: Quoted attributes on components/custom elements will be stringified in future Svelte versions, remove quotes if not desired. [cite: 1598]\n* **`css_unused_selector`**: Unused CSS selectors are removed; use `:global` to preserve them if needed for elements invisible to the compiler (e.g., `{@html ...}`). [cite: 1599, 1600]\n* **`element_invalid_self_closing_tag`**: Self-closing HTML tags for non-void elements are ambiguous and should be explicitly closed. [cite: 1601, 1604, 1605]\n* **`event_directive_deprecated`**: Using `on:%name%` is deprecated; use the event attribute `on%name%` instead. [cite: 1606, 1607]\n* **`export_let_unused`**: Unused `export let` properties should be `export const` if for external reference only. [cite: 1608]\n* **`legacy_code`**: Legacy code is no longer valid and suggests new syntax. [cite: 1608]\n* **`legacy_component_creation`**: Svelte 5 components are functions, use `mount` or `hydrate` for instantiation. [cite: 1609]\n* **`node_invalid_placement_ssr`**: HTML element placement rules violated, causing browser HTML repair which leads to `hydration_mismatch` in SSR. [cite: 1610, 1611, 1612, 1613]\n* **`non_reactive_update`**: A variable updated but not declared with `$state(...)` will not trigger updates correctly. [cite: 1613, 1615]\n* **`options_deprecated_accessors`**: The `accessors` option is deprecated and has no effect in runes mode. [cite: 1617]\n* **`options_deprecated_immutable`**: The `immutable` option is deprecated and has no effect in runes mode. [cite: 1618]\n* **`options_missing_custom_element`**: Warns if `customElement` option is used without `customElement: true` compile option. [cite: 1619]\n* **`options_removed_enable_sourcemap`**: `enableSourcemap` option removed, source maps always generated. [cite: 1620]\n* **`options_removed_hydratable`**: `hydratable` option removed, Svelte components are always hydratable. [cite: 1621]\n* **`script_context_deprecated`**: `context=\"module\"` is deprecated, use the `module` attribute instead. [cite: 1622]\n* **`script_unknown_attribute`**: Unrecognized script attribute. [cite: 1623]\n* **`slot_element_deprecated`**: Using `<slot>` to render parent content is deprecated; use `{@render ...}` tags instead. [cite: 1624, 1625]\n* **`state_referenced_locally`**: A reactive variable referenced locally after reassignment breaks the link to original state. [cite: 1626, 1627, 1630]\n* **`store_rune_conflict`**: `$%name%` rune conflicts with a local binding named `%name%`. [cite: 1633, 1634]\n* **`svelte_component_deprecated`**: `<svelte:component>` is deprecated in runes mode as components are dynamic by default. [cite: 1636]\n* **`svelte_element_invalid_this`**: `this` on `<svelte:element>` should be an `{expression}`; string attribute values will cause errors in future versions. [cite: 1644]\n* **`svelte_self_deprecated`**: `<svelte:self>` is deprecated; use self-imports instead. [cite: 1645]\n* **`unknown_code`**: Unrecognized warning code. [cite: 1645]"}
{"question":"What are common Svelte runtime errors on the client-side?","answer":"Svelte runtime errors occur during the execution of your application in the browser. Common client-side runtime errors include:\n\n* **`bind_invalid_checkbox_value`**: Using `bind:value` with a checkbox input is not allowed; use `bind:checked` instead. [cite: 1646]\n* **`bind_invalid_export`**: A component attempts to bind to an exported property that is not declared as bindable, e.g., `<%name% bind:%key%={...}>`. Instead, use `bind:this` (e.g., `<%name% bind:this={component} />`) and access the property on the bound instance (e.g., `component.%key%`). [cite: 1648]\n* **`bind_not_bindable`**: A component is trying to bind to a non-bindable property. To make a property bindable, use `let { %key% = $bindable() } = $props()`. [cite: 1649]\n* **`component_api_changed`**: Calling `%method%` on a component instance is no longer valid in Svelte 5. [cite: 1650]\n* **`component_api_invalid_new`**: Attempted to instantiate a component with `new %name%`, which is no longer valid in Svelte 5. For components not under your control, set `compatibility.componentApi` to `4`. [cite: 1651]\n* **`derived_references_self`**: A derived value cannot reference itself recursively. [cite: 1651]\n* **`each_key_duplicate`**: A keyed each block has duplicate keys. [cite: 1651]\n* **`effect_in_teardown`**: A rune cannot be used inside an effect cleanup function. [cite: 1651]\n* **`effect_in_unowned_derived`**: An effect cannot be created inside a `$derived` value that was not itself created inside an effect. [cite: 1651]\n* **`effect_orphan`**: A rune can only be used inside an effect (e.g., during component initialisation). [cite: 1651]\n* **`effect_update_depth_exceeded`**: Maximum update depth exceeded, usually due to a reactive block or effect repeatedly setting a new value. [cite: 1652]\n* **`hydration_failed`**: Failed to hydrate the application. [cite: 1653]\n* **`invalid_snippet`**: Could not `{@render}` snippet because the expression was `null` or `undefined`. Consider using optional chaining (`{@render snippet?.()}`). [cite: 1654]\n* **`lifecycle_legacy_only`**: `%name%(...)` cannot be used in runes mode. [cite: 1654]\n* **`props_invalid_value`**: Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value. [cite: 1655]\n* **`props_rest_readonly`**: Rest element properties of `$props()` are readonly. [cite: 1655]\n* **`rune_outside_svelte`**: A rune is only available inside `.svelte` and `.svelte.js/ts` files. [cite: 1655]\n* **`state_descriptors_fixed`**: Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable`, and `writable`. [cite: 1655]\n* **`state_prototype_fixed`**: Cannot set the prototype of a `$state` object. [cite: 1655]\n* **`state_unsafe_mutation`**: Updating state inside a derived value or template expression is forbidden. [cite: 1656] This typically occurs when trying to 'derive' two pieces of state at once, which introduces instability. The solution is usually to make everything derived or use `$effect` for side-effects. [cite: 1657, 1660, 1661, 1662]"}
{"question":"What are common Svelte runtime warnings on the client-side?","answer":"Svelte runtime warnings on the client-side indicate potential issues that don't stop the application from running but might lead to unexpected behavior. These warnings include:\n\n* **`assignment_value_stale`**: An assignment to a property will evaluate to the right-hand side, not the property's value *after* the assignment, potentially leading to unexpected behavior. [cite: 1673, 1674]\n    * Example: If `object.array ??= []` is used and then `.push()` is called on the result, the array being pushed to is the new `[]` on the right-hand side, not the (then empty) state proxy `object.array`, causing the pushed value to be discarded. [cite: 1675, 1676]\n    * Fix: Separate the assignment into two statements. [cite: 1677]\n* **`binding_property_non_reactive`**: A `bind:` directive is binding to a non-reactive property. [cite: 1677]\n* **`console_log_state`**: Logging `$state` proxies directly with `console.log` can be confusing as devtools log the proxy, not its current value. [cite: 1678, 1679] Use `$inspect(...)` or `$state.snapshot(...)` instead. [cite: 1680, 1681]\n* **`event_handler_invalid`**: An event handler is not a function. [cite: 1682]\n* **`hydration_attribute_changed`**: An attribute (like `src` on `<img>`) changed value between server and client renders. The client value is ignored in favor of the server value to prevent re-fetching/reloading. [cite: 1683, 1684] Fix by ensuring consistent values or forcing an update if necessary. [cite: 1686, 1687, 1688]\n* **`hydration_html_changed`**: The value of an `{@html ...}` block changed between server and client renders. The client value is ignored due to performance. [cite: 1690, 1691, 1693] Fix by ensuring consistent values or forcing an update. [cite: 1694, 1695, 1696]\n* **`hydration_mismatch`**: Hydration failed because the initial UI from the server does not match what Svelte expects on the client, often due to invalid HTML. [cite: 1698, 1699, 1700, 1701]\n* **`invalid_raw_snippet_render`**: The `render` function passed to `createRawSnippet` should return HTML for a single element. [cite: 1703]\n* **`legacy_recursive_reactive_block`**: A migrated `$:` reactive block in a file accesses and updates the same reactive value, potentially causing recursive updates when converted to an `$effect`. [cite: 1703, 1704]\n* **`lifecycle_double_unmount`**: Attempted to unmount a component that was not mounted. [cite: 1705]\n* **`ownership_invalid_binding`**: A child component is binding to a property passed by its parent (`<Parent {value} />`) when the parent's parent (`<GrandParent bind:value>`) is binding to it, implying a missing binding in the intermediate component. [cite: 1706, 1707]\n* **`ownership_invalid_mutation`**: Mutating unbound props is strongly discouraged as it makes code hard to reason about. [cite: 1709, 1710] Use `bind:%prop%={...}` or a callback to communicate changes. [cite: 1714, 1715]\n* **`state_proxy_equality_mismatch`**: `$state(...)` creates a proxy with a different identity than the value it proxies, leading to `false` in equality checks. [cite: 1715, 1717] Ensure comparisons are between values both created with `$state(...)` or neither. [cite: 1718]\n* **`transition_slide_display`**: The `slide` transition does not work correctly for elements with `display: inline`, `inline-block`, `inline-flex`, `inline-grid`, `table`, `table-[name]`, or `contents`. [cite: 1719, 1720]"}
{"question":"What are common Svelte runtime errors/warnings that are shared between client and server?","answer":"Some Svelte runtime errors and warnings can occur in both client-side and server-side rendering environments. These shared issues include:\n\n* **`invalid_default_snippet` (Error)**: You cannot use `{@render children(...)}` if the parent component uses `let:` directives. [cite: 1665] This combination of APIs is incompatible, and the solution is to migrate to using snippets completely. [cite: 1668, 1669]\n* **`invalid_snippet_arguments` (Error)**: A snippet function was passed invalid arguments, as snippets should only be instantiated via `{@render ...}`. [cite: 1669]\n* **`lifecycle_outside_component` (Error)**: Lifecycle methods (like `onMount`) can only be used during component initialization, meaning they must be invoked at the top level of the instance script, not inside functions or event handlers. [cite: 1670, 1671, 1672]\n* **`store_invalid_shape` (Error)**: A variable is not a store with a `subscribe` method when treated as one. [cite: 1672]\n* **`svelte_element_invalid_this_value` (Error)**: The `this` prop on `<svelte:element>` must be a string if defined. [cite: 1672]\n* **`dynamic_void_element_content` (Warning)**: `<svelte:element this=\"%tag%\">` is a void element (e.g., `input`) and cannot have content. Any children passed will be ignored. [cite: 1721]\n* **`state_snapshot_uncloneable` (Warning)**: `$state.snapshot` attempts to clone a value, but certain objects (like DOM elements) may not be cloneable, in which case the original value is returned. [cite: 1722, 1723, 1724]"}
{"question":"What is `$state.raw()` and when should you use it?","answer":"`$state.raw()` creates non-reactive state in Svelte 5, which means the values are not automatically converted into deeply reactive proxies. [cite: 56] This is useful for performance optimization when you have large arrays or objects that don't need fine-grained reactivity.\n\nKey characteristics of `$state.raw()`:\n* State declared with `$state.raw()` cannot be mutated directly; it must be *reassigned* to update it. [cite: 57]\n* It improves performance with large, non-mutating arrays and objects by avoiding the overhead of making them reactive. [cite: 60]\n* Raw state can still contain reactive state. [cite: 61]\n\nExample usage:\n```js\nlet person = $state.raw({\n\tname: 'Heraclitus',\n\tage: 49\n});\n\n// this will have no effect\nperson.age += 1;\n\n// this will work, because we're creating a new person\nperson = {\n\tname: 'Heraclitus',\n\tage: 50\n};\n```\n\nUse `$state.raw()` when:\n* You have large datasets that don't need granular reactivity\n* You prefer explicit updates via reassignment rather than mutation\n* You want to optimize performance by avoiding proxy overhead"}
{"question":"What is `$state.snapshot()` and how do you use it?","answer":"`$state.snapshot()` creates a static snapshot of a deeply reactive `$state` proxy, returning the current value without the proxy wrapper. [cite: 62] This is useful when you need to pass state to external libraries or APIs that don't expect a proxy object.\n\nExample usage:\n```svelte\n<script>\n\tlet counter = $state({ count: 0 });\n\tfunction onclick() {\n\t\t// Will log `{ count: ... }` rather than `Proxy { ... }`\n\t\tconsole.log($state.snapshot(counter));\n\t}\n</script>\n\n<button onclick={() => counter.count++}>Increment</button>\n<button {onclick}>Log snapshot</button>\n```\n\nKey use cases:\n* Passing state to external libraries that don't work with proxies\n* Debugging - getting a clean view of the actual data structure\n* Serialization - when you need a plain JavaScript object\n* Comparing state values without proxy interference\n\nNote: `$state.snapshot()` attempts to clone values, but certain objects (like DOM elements) may not be cloneable, in which case the original value is returned. [cite: 1722, 1723, 1724]"}
{"question":"What is `$effect.pre()` and when should you use it?","answer":"`$effect.pre()` runs code *before* DOM updates, unlike regular `$effect()` which runs after DOM updates. [cite: 135] Aside from timing, `$effect.pre()` functions identically to `$effect()`. [cite: 138]\n\nExample usage:\n```svelte\n<script>\n\timport { tick } from 'svelte';\n\n\t$effect.pre(() => {\n\t\tconsole.log('the component is about to update');\n\t\ttick().then(() => {\n\t\t\tconsole.log('the component just updated');\n\t\t});\n\t});\n</script>\n```\n\nUse `$effect.pre()` when you need to:\n* Measure DOM elements before they change\n* Prepare data before the UI updates\n* Perform calculations based on the current DOM state\n* Implement custom animations that need to read DOM properties before updates\n\nThis is particularly useful for scenarios where you need to capture the \"before\" state of the DOM for transitions, measurements, or other pre-update operations."}
{"question":"What are `$effect.tracking()` and `$effect.root()`?","answer":"These are advanced effect runes available since Svelte 5.11.0 for manual control over effect behavior:\n\n**`$effect.tracking()`** indicates whether code is currently running within a tracking context, such as an effect or template. [cite: 139] This is useful for conditional logic based on reactive context.\n\n**`$effect.root()`** creates a non-tracked scope that does not auto-cleanup, allowing manual control of nested effects or creating effects outside component initialization. [cite: 141, 142]\n\nExample of `$effect.root()`:\n```js\n// Create an effect that doesn't auto-cleanup\nconst dispose = $effect.root(() => {\n\t$effect(() => {\n\t\t// This effect won't be automatically cleaned up\n\t\t// when the parent component is destroyed\n\t\tconsole.log('Manual effect');\n\t});\n\t\n\t// Return cleanup function\n\treturn () => {\n\t\tconsole.log('Manual cleanup');\n\t};\n});\n\n// Later, manually dispose\ndispose();\n```\n\nUse cases:\n* **`$effect.tracking()`**: Conditional reactive behavior, debugging reactive contexts\n* **`$effect.root()`**: Global effects, manual effect lifecycle management, effects that should persist beyond component lifecycle"}
{"question":"What is the `untrack()` function and how do you use it?","answer":"The `untrack()` function prevents pieces of state from being tracked as dependencies within reactive contexts like `$derived()` and `$effect()`. [cite: 92] This gives you fine-grained control over what triggers reactive updates.\n\nExample usage in `$derived()`:\n```svelte\n<script>\n\timport { untrack } from 'svelte';\n\t\n\tlet count = $state(0);\n\tlet multiplier = $state(2);\n\t\n\t// This derived value only reacts to `count` changes,\n\t// not `multiplier` changes\n\tlet result = $derived(() => {\n\t\treturn count * untrack(() => multiplier);\n\t});\n</script>\n```\n\nExample usage in `$effect()`:\n```svelte\n<script>\n\timport { untrack } from 'svelte';\n\t\n\tlet data = $state({ items: [] });\n\tlet debugMode = $state(false);\n\t\n\t$effect(() => {\n\t\t// Effect only runs when `data` changes,\n\t\t// not when `debugMode` changes\n\t\tprocessData(data);\n\t\t\n\t\tif (untrack(() => debugMode)) {\n\t\t\tconsole.log('Processing data:', data);\n\t\t}\n\t});\n</script>\n```\n\nUse `untrack()` when:\n* You want to read state without creating a dependency\n* You need conditional logic that shouldn't trigger re-runs\n* You want to optimize performance by limiting reactive dependencies"}
{"question":"How does push-pull reactivity work in Svelte 5?","answer":"Svelte 5 uses *push-pull reactivity*, a hybrid approach that optimizes performance by combining immediate notifications with lazy evaluation. [cite: 101]\n\nHow it works:\n* **Push phase**: When state is updated, dependent elements are notified immediately ('push')\n* **Pull phase**: Derived values are only re-evaluated when actually read ('pull')\n\nExample:\n```svelte\n<script>\n\tlet count = $state(0);\n\tlet doubled = $derived(() => {\n\t\tconsole.log('Computing doubled');\n\t\treturn count * 2;\n\t});\n\tlet quadrupled = $derived(() => {\n\t\tconsole.log('Computing quadrupled');\n\t\treturn doubled * 2;\n\t});\n</script>\n\n<!-- Only logs when count changes AND doubled is accessed -->\n<p>{count}</p>\n\n<!-- This will trigger both computations -->\n<button onclick={() => count++}>Increment</button>\n\n<!-- This will only show quadrupled if this line is uncommented -->\n<!-- <p>{quadrupled}</p> -->\n```\n\nPerformance benefits:\n* Derived values that aren't accessed don't get computed\n* Referential equality checks skip downstream updates if values haven't actually changed [cite: 102]\n* Updates are batched and optimized\n\nThis approach ensures that your app stays fast by only doing work when necessary, while still maintaining the reactive guarantees you expect."}
{"question":"When should you use function bindings instead of effects?","answer":"In Svelte 5, function bindings (using `oninput` callbacks) are often preferred over effects for linking values and handling user input. [cite: 156] This approach is more direct and avoids unnecessary reactive overhead.\n\n**Instead of using `$effect()` for input handling:**\n```svelte\n<!-- Avoid this pattern -->\n<script>\n\tlet value = $state('');\n\tlet processed = $state('');\n\t\n\t$effect(() => {\n\t\tprocessed = value.toUpperCase();\n\t});\n</script>\n\n<input bind:value />\n```\n\n**Use function bindings:**\n```svelte\n<!-- Prefer this pattern -->\n<script>\n\tlet value = $state('');\n\tlet processed = $state('');\n\t\n\tfunction handleInput(event) {\n\t\tvalue = event.target.value;\n\t\tprocessed = value.toUpperCase();\n\t}\n</script>\n\n<input {value} oninput={handleInput} />\n```\n\n**Or use derived state:**\n```svelte\n<!-- Even better for computed values -->\n<script>\n\tlet value = $state('');\n\tlet processed = $derived(value.toUpperCase());\n</script>\n\n<input bind:value />\n```\n\nUse function bindings when:\n* Handling user input events\n* You need synchronous updates\n* You want explicit control over when updates happen\n* You're performing simple transformations or validations\n\nUse `$effect()` when:\n* Integrating with third-party libraries\n* Performing side effects (API calls, DOM manipulation)\n* Setting up/cleaning up resources\n* Working with asynchronous operations"}
{"question":"What are the performance considerations for different state management approaches in Svelte 5?","answer":"Different state management approaches in Svelte 5 have varying performance characteristics. Here's how to optimize your choice:\n\n**`$state()` vs `$state.raw()`:**\n* `$state()`: Creates deep reactive proxies, best for most use cases\n* `$state.raw()`: Avoids proxy overhead, better for large datasets that don't need fine-grained reactivity [cite: 60]\n\n```js\n// For large, infrequently changing data\nlet bigDataset = $state.raw(thousandsOfItems);\n\n// For interactive, frequently changing data\nlet userInput = $state({ name: '', email: '' });\n```\n\n**`$derived()` vs `$effect()`:**\n* `$derived()`: Lazy evaluation, only computes when accessed\n* `$effect()`: Eager execution, runs immediately when dependencies change\n\n```js\n// Efficient - only computes when displayed\nlet expensiveComputation = $derived(() => {\n\treturn heavyCalculation(data);\n});\n\n// Less efficient if not always needed\n$effect(() => {\n\tresult = heavyCalculation(data);\n});\n```\n\n**Optimization strategies:**\n1. **Use `$derived()` for computed values** - leverages push-pull reactivity [cite: 101]\n2. **Use `$state.raw()` for large, immutable data** - avoids proxy overhead\n3. **Use `untrack()` to limit dependencies** - prevents unnecessary re-runs [cite: 92]\n4. **Prefer function bindings over effects** for simple transformations [cite: 156]\n5. **Use `$state.snapshot()` when interfacing with external libraries** [cite: 62]\n\n**Memory considerations:**\n* Proxies add memory overhead but enable fine-grained updates\n* Deep reactive structures can lead to many proxy objects\n* Use `$state.raw()` for data that doesn't benefit from reactivity"}
{"question":"What are the best practices for using Svelte 5 runes?","answer":"Here are the key best practices for effectively using Svelte 5 runes:\n\n**State Management:**\n* Use `$state()` for most reactive data that needs fine-grained updates\n* Use `$state.raw()` for large datasets or data that changes infrequently [cite: 56, 60]\n* Avoid destructuring reactive state - it breaks reactivity [cite: 49, 50]\n\n```js\n// Good\nlet user = $state({ name: 'John', age: 30 });\nuser.name = 'Jane'; // Reactive\n\n// Avoid\nlet { name, age } = user; // Breaks reactivity\n```\n\n**Derived State:**\n* Prefer `$derived()` over `$effect()` for computed values [cite: 147]\n* Keep derivations pure and side-effect free [cite: 84]\n* Use `untrack()` to prevent unwanted dependencies [cite: 92]\n\n**Effects:**\n* Use `$effect()` only for side effects, not state synchronization [cite: 145]\n* Always return cleanup functions when setting up resources [cite: 113, 116]\n* Use `$effect.pre()` for pre-DOM update operations [cite: 135]\n\n```js\n$effect(() => {\n\tconst interval = setInterval(() => {\n\t\t// side effect\n\t}, 1000);\n\t\n\treturn () => clearInterval(interval); // cleanup\n});\n```\n\n**Props:**\n* Use TypeScript or JSDoc for type safety [cite: 176, 177, 178]\n* Mark props as `$bindable()` only when two-way binding is needed [cite: 184]\n* Provide meaningful fallback values [cite: 161]\n\n**Performance:**\n* Use function bindings instead of effects for simple input handling [cite: 156]\n* Use `$state.snapshot()` when passing data to external libraries [cite: 62]\n* Consider `$effect.root()` for global effects that persist beyond components [cite: 141, 142]\n\n**Debugging:**\n* Use `$inspect()` instead of `console.log()` for reactive values [cite: 195]\n* Use `$inspect.trace()` to debug reactive dependencies [cite: 202, 203]"}
{"question":"What is the untrack() function in Svelte 5?","answer":"The `untrack()` function in Svelte 5 allows you to exempt a piece of state from being treated as a dependency in reactive contexts. This is crucial for fine-grained reactivity control and preventing unwanted re-executions. Key use cases include: In derived expressions to read state without creating reactive dependencies, In effects to access state without triggering effect re-runs, Breaking infinite loops when you must update $state within an effect, In load functions to prevent certain changes from triggering reruns. Example: `$effect(() => { console.log(count); untrack(() => console.log(otherValue)); });` The `untrack()` function is essential for advanced reactivity patterns and preventing unnecessary computations in complex applications."}
{"question":"What are the reactive built-in classes in Svelte 5?","answer":"Svelte 5 provides several reactive built-in classes that wrap JavaScript standard objects with reactivity: **SvelteMap** - Reactive version of JavaScript Map, tracks map changes in effects and derived values, values are not deeply reactive, use for reactive key-value collections. **SvelteSet** - Reactive version of JavaScript Set, tracks set changes in effects and derived values, values are not deeply reactive, use for reactive unique collections. **SvelteDate** - Reactive version of JavaScript Date object, re-evaluates when date changes, useful for time-based reactivity. **SvelteURL** - Reactive version of the URL object, tracks URL property changes, includes reactive searchParams. **MediaQuery** - Creates a reactive media query, has a current property reflecting whether query matches, caution: can cause content shifts during SSR. These classes integrate seamlessly with Svelte's reactivity system and provide minimal performance overhead while enabling reactive patterns with standard JavaScript objects."}
{"question":"What is $derived.by() and how is it different from $derived?","answer":"While `$derived` works with simple expressions, `$derived.by()` is used for complex derivations that require multiple statements or logic. $derived takes a single expression like `let doubled = $derived(count * 2);` while $derived.by() takes a function that can contain multiple statements like `let total = $derived.by(() => { let total = 0; for (const n of numbers) { total += n; } return total; });` Key differences: $derived takes a single expression, $derived.by() takes a function that can contain multiple statements, both track dependencies automatically, both provide lazy evaluation and referential equality checks, both support the new override feature in Svelte 5.25+ for optimistic UI updates. $derived.by() is essential for complex computations that cannot be expressed as a single expression."}
{"question":"What are Svelte 5 performance optimization best practices?","answer":"Svelte 5 performance optimization involves several key strategies: **Reactive Patterns** - Use `$state.raw()` for large objects that do not need deep reactivity, Prefer `$derived` over `$effect` for state transformations, Use `untrack()` to prevent unnecessary dependency tracking, Narrow reactive scope in `$:` statements. **Component Optimization** - Use keyed each blocks for efficient list rendering (50% faster updates), Implement code splitting with dynamic imports, Load components lazily when needed, Use memoization for expensive computations. **Store Management** - Do not subscribe to global stores in deeply nested components unnecessarily, Use derived stores to avoid recalculating in multiple places, Use `get(store)` only outside reactive contexts. **Asset Optimization** - Use `@sveltejs/enhanced-img` for optimized images, Monitor CSS bundle sizes and remove unused styles, Implement streaming and asynchronous loading. **Compile-time Benefits** - Svelte compiler eliminates virtual DOM overhead, Smaller bundle sizes compared to runtime frameworks, Automatic dead code elimination. These optimizations can improve loading times by 30%+ and rendering performance by 50%+ in many cases."}
{"question":"What is snippet recursion and how does it work in Svelte 5?","answer":"Snippet recursion in Svelte 5 allows snippets to reference and call themselves, enabling powerful recursive rendering patterns. Basic recursive snippet: `{#snippet countdown(n)} {#if n > 0} {n}... {@render countdown(n - 1)} {:else} blastoff! {/if} {/snippet} {@render countdown(10)}` Advanced recursive patterns include: Tree structures (file explorers, nested comments), Nested menus and navigation, Fractal-like UI components, Dynamic form builders. Key characteristics: Snippets exist within the same lexical scope as their declaration, Can reference external variables from script tags, Support multiple parameters with default values, Can be passed as props to other components, TypeScript support via the `Snippet` interface. Performance considerations: Set proper base cases to prevent infinite recursion, Consider depth limits for deeply nested structures, Use conditional rendering to optimize unnecessary renders. Recursive snippets are more powerful and flexible than Svelte 4 slots, providing elegant solutions for hierarchical data visualization."}
{"question":"What are advanced $effect patterns and timing considerations?","answer":"Svelte 5 provides sophisticated effect patterns for different timing requirements. **Effect Variants**: `$effect()` runs after DOM updates in a microtask, `$effect.pre()` runs before DOM updates (useful for autoscrolling), `$effect.root()` creates non-tracked scope with manual cleanup control. **Advanced Patterns**: Cleanup and Resource Management: `$effect(() => { const subscription = subscribe(); return () => subscription.unsubscribe(); });` Conditional Tracking: `$effect(() => { if ($effect.tracking()) { /* code that should only run in reactive context */ } });` Manual Effect Creation: `const dispose = $effect.root(() => { $effect(() => { console.log('Manual effect'); }); return () => {/* manual cleanup */}; });` **Best Practices**: Avoid updating state inside effects (use $derived instead), Use for side effects like analytics and DOM manipulation, Batch re-runs occur for simultaneous state changes, Effects run only in browser not during SSR, Use `untrack()` when state updates are absolutely necessary. These patterns provide fine-grained control over reactive behavior and effect lifecycle management."}
{"question":"What is createSubscriber() and how does it integrate external systems?","answer":"The `createSubscriber()` function in Svelte 5 integrates external event-based systems with Svelte reactivity system. **Purpose**: Bridge non-Svelte reactive systems with Svelte reactivity, Manage complex reactive scenarios, Handle effect updates and cleanup automatically. **Use Cases**: WebSocket connections, External state management libraries, Third-party observable systems, Custom event emitters, Browser APIs (ResizeObserver, IntersectionObserver). **Basic Pattern**: `import { createSubscriber } from 'svelte'; const subscriber = createSubscriber((set) => { const unsubscribe = externalSystem.subscribe(set); return unsubscribe; }); $effect(() => { console.log(subscriber.current); });` **Key Features**: Automatically manages subscription lifecycle, Provides reactive `.current` property, Handles cleanup when components unmount, Minimal performance overhead, Seamless integration with effects and derived values. `createSubscriber()` is essential for building complex applications that need to integrate multiple reactive systems while maintaining Svelte performance characteristics."}
{"question":"What are Svelte 5 compilation and bundle optimization strategies?","answer":"Svelte 5 provides several compilation and bundle optimization strategies. **Compile-time Optimizations**: Automatic dead code elimination, Component tree shaking, CSS purging and optimization, Static analysis for reactive dependencies, Ahead-of-time template compilation. **Bundle Size Strategies**: Dynamic imports for code splitting: `const Component = await import('./Component.svelte')`, Route-based splitting in SvelteKit, Lazy loading of non-critical components, Tree shaking of unused library code. **CSS Optimization**: Scoped CSS by default (no CSS-in-JS runtime overhead), Automatic unused CSS removal, CSS bundling and minification, Critical CSS extraction. **Advanced Techniques**: Use `@sveltejs/enhanced-img` for automatic image optimization, Implement service worker caching strategies, Optimize font loading with `font-display: swap`, Use component-level code splitting. **Build Configuration**: Configure Vite for optimal bundling, Enable Rollup optimizations, Use proper source maps for debugging, Implement compression (gzip/brotli). **Performance Benefits**: 25%+ smaller bundles compared to virtual DOM frameworks, Faster initial load times, No runtime framework overhead, Efficient update mechanisms. These strategies leverage Svelte compiler-first philosophy to deliver optimal performance with minimal configuration."}