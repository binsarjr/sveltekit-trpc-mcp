{"instruction":"Create a Svelte 5 component demonstrating Overview: Svelte is a framework for building user interfaces on the web.","input":"Svelte is a framework for building user interfaces on the web. It uses a compiler to turn declarative components written in HTML, CSS and JavaScript.","output":"<!file: App.svelte>\n<script>\nfunction greet() {\n  alert('Welcome to Svelte!');\n}\n</script>\n\n<button onclick={greet}>click me</button>\n\n<style>\nbutton {\n  font-size: 2em;\n}\n</style>"}
{"instruction":"Write Svelte 5 code for .svelte files.","input":"Components are the building blocks of Svelte applications. They are written into .svelte files, using a superset of HTML. All three sections â€” script, styles and markup â€” are optional.","output":"<script module>\n// module-level logic goes here\n// (you will rarely use this)\n</script>\n\n<script>\n// instance-level logic goes here\n</script>\n\n<style>\n/* styles go here */\n</style>"}
{"instruction":"Create a Svelte 5 component demonstrating .svelte files: A tag with a attribute runs once when the module first evaluates, rather than for each component instance.","input":"A tag with a attribute runs once when the module first evaluates, rather than for each component instance. Variables declared in this block can be referenced elsewhere in the component, but not vice versa.","output":"<script module>\nlet total = 0;\n</script>\n\n<script>\ntotal += 1;\nconsole.log(`instantiated ${total} times`);\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating .svelte files: CSS inside a block will be scoped to that component.","input":"CSS inside a block will be scoped to that component.","output":"<style>\np {\n  /* this will only affect <p> elements in this component */\n  color: burlywood;\n}\n</style>"}
{"instruction":"Create a Svelte 5 component demonstrating $state: The rune allows you to create which means that your UI when it changes.","input":"The rune allows you to create which means that your UI when it changes.","output":"<script>\nlet count = $state(0);\n</script>\n\n<button onclick={() => count++}>\n  clicks: {count}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating $state: If is used with an array or a simple object, the result is a deeply reactive .","input":"If is used with an array or a simple object, the result is a deeply reactive . allow Svelte to run code when you read or write properties, including via methods like triggering granular updates. State is proxified recursively until Svelte finds something other than an array or simple object. In a case like this.","output":"let todos = $state([\n  { done: false, text: 'add more todos' }\n]);"}
{"instruction":"Create a Svelte 5 component demonstrating $state: ...modifying an individual todo's property will trigger updates to anything in your UI that depends on that specific property:","input":"...modifying an individual todo's property will trigger updates to anything in your UI that depends on that specific property:","output":"let todos = [{ done: false, text: 'add more todos' }];\ntodos[0].done = !todos[0].done;"}
{"instruction":"Create a Svelte 5 component demonstrating $state: If you push a new object to the array, it will also be proxified:","input":"If you push a new object to the array, it will also be proxified:","output":"let todos = [{ done: false, text: 'add more todos' }];\ntodos.push({ done: false, text: 'eat lunch' });"}
{"instruction":"Create a Svelte 5 component demonstrating $state: Note that if you destructure a reactive value, the references are not reactive â€” as in normal JavaScript, they are evaluated at the point of destructuring:","input":"Note that if you destructure a reactive value, the references are not reactive â€” as in normal JavaScript, they are evaluated at the point of destructuring:","output":"let todos = [{ done: false, text: 'add more todos' }];\nlet { done, text } = todos[0];\n\n// this will not affect the value of `done`\ntodos[0].done = !todos[0].done;"}
{"instruction":"Create a Svelte 5 component demonstrating $state: You can also use in class fields (whether public or private):","input":"You can also use in class fields (whether public or private):","output":"class Todo {\n  done = $state(false);\n  text = $state();\n\n  constructor(text) {\n    this.text = text;\n  }\n\n  reset() {\n    this.text = '';\n    this.done = false;\n  }\n}"}
{"instruction":"Create a Svelte 5 component demonstrating $state: This won't work, because inside the method will be the rather than the :","input":"This won't work, because inside the method will be the rather than the :","output":"<button onclick={todo.reset}>\n  reset\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating $state: You can either use an inline function...","input":"You can either use an inline function...","output":"<button onclick={() => todo.reset()}>\n  reset\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating $state: ...or use an arrow function in the class definition:","input":"...or use an arrow function in the class definition:","output":"class Todo {\n  done = $state(false);\n  text = $state();\n\n  constructor(text) {\n    this.text = text;\n  }\n\n  reset = () => {\n    this.text = '';\n    this.done = false;\n  }\n}"}
{"instruction":"Create a Svelte 5 component demonstrating $state: In cases where you don't want objects and arrays to be deeply reactive you can use .","input":"In cases where you don't want objects and arrays to be deeply reactive you can use . State declared with cannot be mutated; it can only be . In other words, rather than assigning to a property of an object, or using an array method like replace the object or array altogether if you'd like to update it:","output":"let person = $state.raw({ name: 'Heraclitus', age: 49 });\n\n// this will have no effect\nperson.age += 1;\n\n// this will work, because we're creating a new person\nperson = { name: 'Heraclitus', age: 50 };"}
{"instruction":"Create a Svelte 5 component demonstrating $state: To take a static snapshot of a deeply reactive proxy, use :","input":"To take a static snapshot of a deeply reactive proxy, use :","output":"<script>\nlet counter = $state({ count: 0 });\n\nfunction onclick() {\n  // Will log `{ count: ... }` rather than `Proxy { ... }`\n  console.log($state.snapshot(counter));\n}\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating $derived: Derived state is declared with the rune:","input":"Derived state is declared with the rune:","output":"<script>\nlet count = $state(0);\nlet doubled = $derived(count * 2);\n</script>\n\n<button onclick={() => count++}>\n  {doubled}\n</button>\n\n<p>{count} doubled is {doubled}</p>"}
{"instruction":"Create a Svelte 5 component demonstrating $derived: Sometimes you need to create complex derivations that don't fit inside a short expression.","input":"Sometimes you need to create complex derivations that don't fit inside a short expression. In these cases, you can use which accepts a function as its argument.","output":"<script>\nlet numbers = $state([1, 2, 3]);\n\nlet total = $derived.by(() => {\n  let total = 0;\n  for (const n of numbers) {\n    total += n;\n  }\n  return total;\n});\n</script>\n\n<button onclick={() => numbers.push(numbers.length + 1)}>\n  {numbers.join(' + ')} = {total}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating $derived: Derived expressions are recalculated when their dependencies change, but you can temporarily override their values by reassigning them (unless they are declared with ).","input":"Derived expressions are recalculated when their dependencies change, but you can temporarily override their values by reassigning them (unless they are declared with ). This can be useful for things like where a value is derived from the 'source of truth' (such as data from your server) but you'd like to show immediate feedback to the user:","output":"<script>\nlet { post, like } = $props();\n\nlet likes = $derived(post.likes);\n\nasync function onclick() {\n  // increment the `likes` count immediately...\n  likes += 1;\n\n  // and tell the server, which will eventually update `post`\n  try {\n    await like();\n  } catch {\n    // failed! roll back the change\n    likes -= 1;\n  }\n}\n</script>\n\n<button {onclick}>ðŸ§¡ {likes}</button>"}
{"instruction":"Create a Svelte 5 component demonstrating $derived: ...you can change (or to) properties of and it will affect the underlying array.","input":"...you can change (or to) properties of and it will affect the underlying array. If was reactive, mutating would have no effect.","output":"let items = $state([...]);\nlet index = $state(0);\nlet selected = $derived(items[index]);"}
{"instruction":"Create a Svelte 5 component demonstrating $derived: Svelte uses something called â€” when state is updated, everything that depends on the state (whether directly or indirectly) is immediately notified of the change (the 'push'), but derived values are not re-evaluated until they are actually read (the 'pull').","input":"Svelte uses something called â€” when state is updated, everything that depends on the state (whether directly or indirectly) is immediately notified of the change (the 'push'), but derived values are not re-evaluated until they are actually read (the 'pull'). If the new value of a derived is referentially identical to its previous value, downstream updates will be skipped. In other words, Svelte will only update the text inside the button when changes, not when changes, even though depends on :","output":"<script>\nlet count = $state(0);\nlet large = $derived(count > 10);\n</script>\n\n<button onclick={() => count++}>\n  {large}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating $effect: You can create an effect with the rune ( ):","input":"You can create an effect with the rune ( ):","output":"<script>\nlet size = $state(50);\nlet color = $state('#ff3e00');\nlet canvas;\n\n$effect(() => {\n  const context = canvas.getContext('2d');\n  context.clearRect(0, 0, canvas.width, canvas.height);\n\n  // this will re-run whenever `color` or `size` change\n  context.fillStyle = color;\n  context.fillRect(0, 0, size, size);\n});\n</script>\n\n<canvas bind:this={canvas} width=\"100\" height=\"100\"></canvas>"}
{"instruction":"Create a Svelte 5 component demonstrating $effect: An effect can return a which will run immediately before the effect re-runs ( ):","input":"An effect can return a which will run immediately before the effect re-runs ( ):","output":"<script>\nlet count = $state(0);\nlet milliseconds = $state(1000);\n\n$effect(() => {\n  // This will be recreated whenever `milliseconds` changes\n  const interval = setInterval(() => {\n    count += 1;\n  }, milliseconds);\n\n  return () => {\n    // if a teardown function is provided, it will run\n    // a) immediately before the effect re-runs\n    // b) when the component is destroyed\n    clearInterval(interval);\n  };\n});\n</script>\n\n<h1>{count}</h1>\n\n<button onclick={() => (milliseconds *= 2)}>slower</button>\n<button onclick={() => (milliseconds /= 2)}>faster</button>"}
{"instruction":"Create a Svelte 5 component demonstrating $effect: An effect only reruns when the object it reads changes, not when a property inside it changes.","input":"An effect only reruns when the object it reads changes, not when a property inside it changes. (If you want to observe changes an object at dev time, you can use .)","output":"<script>\nlet state = $state({ value: 0 });\nlet derived = $derived({ value: state.value * 2 });\n\n// this will run once, because `state` is never reassigned (only mutated)\n$effect(() => {\n  state;\n});\n\n// this will run whenever `state.value` changes...\n$effect(() => {\n  state.value;\n});\n\n// ...and so will this, because `derived` is a new object each time\n$effect(() => {\n  derived;\n});\n</script>\n\n<button onclick={() => (state.value += 1)}>\n  {state.value}\n</button>\n\n<p>{state.value} doubled is {derived.value}</p>"}
{"instruction":"Create a Svelte 5 component demonstrating $effect.pre: In rare cases, you may need to run code the DOM updates.","input":"In rare cases, you may need to run code the DOM updates. For this we can use the rune:","output":"<script>\nimport { tick } from 'svelte';\n\nlet div = $state();\nlet messages = $state([]);\n\n// ...\n\n$effect.pre(() => {\n  if (!div) return; // not yet mounted\n\n  // reference `messages` array length so that this code re-runs whenever it changes\n  messages.length;\n\n  // autoscroll when new messages are added\n  if (div.offsetHeight + div.scrollTop > div.scrollHeight - 20) {\n    tick().then(() => {\n      div.scrollTo(0, div.scrollHeight);\n    });\n  }\n});\n</script>\n\n<div bind:this={div}>\n  {#each messages as message}\n    <p>{message}</p>\n  {/each}\n</div>"}
{"instruction":"Create a Svelte 5 component demonstrating $effect.tracking: The rune is an advanced feature that tells you whether or not the code is running inside a tracking context, such as an effect or inside your template ( ):","input":"The rune is an advanced feature that tells you whether or not the code is running inside a tracking context, such as an effect or inside your template ( ):","output":"<script>\nconsole.log('in component setup:', $effect.tracking()); // false\n\n$effect(() => {\n  console.log('in effect:', $effect.tracking()); // true\n});\n</script>\n\n<p>in template: {$effect.tracking()}</p>"}
{"instruction":"Create a Svelte 5 component demonstrating $effect: Instead of this...","input":"Instead of this...","output":"<script>\nlet count = $state(0);\nlet doubled = $state();\n\n// don't do this!\n$effect(() => {\n  doubled = count * 2;\n});\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating $effect: ...do this:","input":"...do this:","output":"<script>\nlet count = $state(0);\nlet doubled = $derived(count * 2);\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating $effect: You might be tempted to do something convoluted with effects to link one value to another.","input":"You might be tempted to do something convoluted with effects to link one value to another. The following example shows two inputs for \"money spent\" and \"money left\" that are connected to each other. If you update one, the other should update accordingly. Don't use effects for this ( ):","output":"<script>\nlet total = 100;\nlet spent = $state(0);\nlet left = $state(total);\n\n$effect(() => {\n  left = total - spent;\n});\n\n$effect(() => {\n  spent = total - left;\n});\n</script>\n\n<label>\n  <input type=\"range\" bind:value={spent} max={total} />\n  {spent}/{total} spent\n</label>\n\n<label>\n  <input type=\"range\" bind:value={left} max={total} />\n  {left}/{total} left\n</label>"}
{"instruction":"Create a Svelte 5 component demonstrating $effect: Instead, use callbacks or â€” better still â€” where possible ( ):","input":"Instead, use callbacks or â€” better still â€” where possible ( ):","output":"<script>\nlet total = 100;\nlet spent = $state(0);\nlet left = $state(total);\n\nfunction updateSpent(value) {\n  spent = value;\n  left = total - spent;\n}\n\nfunction updateLeft(value) {\n  left = value;\n  spent = total - left;\n}\n</script>\n\n<label>\n  <input type=\"range\" bind:value={() => spent, updateSpent} max={total} />\n  {spent}/{total} spent\n</label>\n\n<label>\n  <input type=\"range\" bind:value={() => left, updateLeft} max={total} />\n  {left}/{total} left\n</label>"}
{"instruction":"Create a Svelte 5 component demonstrating $props: The inputs to a component are referred to as which is short for .","input":"The inputs to a component are referred to as which is short for . You pass props to components just like you pass attributes to elements:","output":"<!file: App.svelte>\n<script>\nimport MyComponent from './MyComponent.svelte';\n</script>\n\n<MyComponent adjective=\"cool\" />"}
{"instruction":"Create a Svelte 5 component demonstrating $props: On the other side, inside we can receive props with the rune...","input":"On the other side, inside we can receive props with the rune...","output":"<!file: MyComponent.svelte>\n<script>\nlet props = $props();\n</script>\n\n<p>this component is {props.adjective}</p>"}
{"instruction":"Create a Svelte 5 component demonstrating $props: ...though more commonly, you'll your props:","input":"...though more commonly, you'll your props:","output":"<!file: MyComponent.svelte>\n<script>\nlet{ adjective }= $props();\n</script>\n\n<p>this component is {adjective}</p>"}
{"instruction":"Create a Svelte 5 component demonstrating $props: References to a prop inside a component update when the prop itself updates â€” when changes in it will also change inside .","input":"References to a prop inside a component update when the prop itself updates â€” when changes in it will also change inside . But the child component is able to temporarily override the prop value, which can be useful for unsaved ephemeral state ( ):","output":"<!file: App.svelte>\n<script>\nimport Child from './Child.svelte';\n\nlet count = $state(0);\n</script>\n\n<button onclick={() => (count += 1)}>\n  clicks (parent): {count}\n</button>\n\n<Child {count} />"}
{"instruction":"Write Svelte 5 code for $props.","input":"","output":"<!file: Child.svelte>\n<script>\nlet { count } = $props();\n</script>\n\n<button onclick={() => (count += 1)}>\n  clicks (child): {count}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating $props: If the prop is a regular object, the mutation will have no effect ( ):","input":"If the prop is a regular object, the mutation will have no effect ( ):","output":"<!file: App.svelte>\n<script>\nimport Child from './Child.svelte';\n</script>\n\n<Child object={{ count: 0 }} />"}
{"instruction":"Write Svelte 5 code for $props.","input":"","output":"<!file: Child.svelte>\n<script>\nlet { object } = $props();\n</script>\n\n<button onclick={() => {\n  // has no effect\n  object.count += 1\n}}>\n  clicks: {object.count}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating $props: If the prop is a reactive state proxy, however, then mutations have an effect but you will see an warning, because the component is mutating state that does not 'belong' to it ( ):","input":"If the prop is a reactive state proxy, however, then mutations have an effect but you will see an warning, because the component is mutating state that does not 'belong' to it ( ):","output":"<!file: App.svelte>\n<script>\nimport Child from './Child.svelte';\n\nlet object = $state({count: 0});\n</script>\n\n<Child {object} />"}
{"instruction":"Write Svelte 5 code for $props.","input":"","output":"<!file: Child.svelte>\n<script>\nlet { object } = $props();\n</script>\n\n<button onclick={() => {\n  // will cause the count below to update,\n  // but with a warning. Don't mutate\n  // objects you don't own!\n  object.count += 1\n}}>\n  clicks: {object.count}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating $props: The fallback value of a prop not declared with is left untouched â€” it is not turned into a reactive state proxy â€” meaning mutations will not cause updates ( )","input":"The fallback value of a prop not declared with is left untouched â€” it is not turned into a reactive state proxy â€” meaning mutations will not cause updates ( )","output":"<!file: Child.svelte>\n<script>\nlet { object = { count: 0 } } = $props();\n</script>\n\n<button onclick={() => {\n  // has no effect if the fallback value is used\n  object.count += 1\n}}>\n  clicks: {object.count}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating $props: You can add type safety to your components by annotating your props, as you would with any other variable declaration.","input":"You can add type safety to your components by annotating your props, as you would with any other variable declaration. In TypeScript that might look like this...","output":"<script lang=\"ts\">\nlet { adjective }: { adjective: string } = $props();\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating $props: ...while in JSDoc you can do this:","input":"...while in JSDoc you can do this:","output":"<script>\n/** @type {{ adjective: string }} */\nlet { adjective } = $props();\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating $props: You can, of course, separate the type declaration from the annotation:","input":"You can, of course, separate the type declaration from the annotation:","output":"<script lang=\"ts\">\ninterface Props {\n  adjective: string;\n}\n\nlet { adjective }: Props = $props();\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating $props.id(): This rune, added in version 5.20.0, generates an ID that is unique to the current component instance.","input":"This rune, added in version 5.20.0, generates an ID that is unique to the current component instance. When hydrating a server-rendered component, the value will be consistent between server and client. This is useful for linking elements via attributes like and .","output":"<script>\nconst uid = $props.id();\n</script>\n\n<form>\n  <label for=\"{uid}-firstname\">First Name: </label>\n  <input id=\"{uid}-firstname\" type=\"text\" />\n\n  <label for=\"{uid}-lastname\">Last Name: </label>\n  <input id=\"{uid}-lastname\" type=\"text\" />\n</form>"}
{"instruction":"Create a Svelte 5 component demonstrating $bindable: Ordinarily, props go one way, from parent to child.","input":"Ordinarily, props go one way, from parent to child. This makes it easy to understand how data flows around your app. In Svelte, component props can be which means that data can also flow from child to parent. This isn't something you should do often, but it can simplify your code if used sparingly and carefully. It also means that a state proxy can be in the child. To mark a prop as bindable, we use the rune:","output":"<script>\nlet { value = $bindable(), ...props } = $props();\n</script>\n\n<input bind:value={value} {...props} />\n\n<style>\ninput {\n  font-family: 'Comic Sans MS';\n  color: deeppink;\n}\n</style>"}
{"instruction":"Create a Svelte 5 component demonstrating $bindable: Now, a component that uses can add the directive ( ):","input":"Now, a component that uses can add the directive ( ):","output":"<script>\nimport FancyInput from './FancyInput.svelte';\n\nlet message = $state('hello');\n</script>\n\n<FancyInput bind:value={message} />\n<p>{message}</p>"}
{"instruction":"Create a Svelte 5 component demonstrating $inspect: The rune is roughly equivalent to with the exception that it will re-run whenever its argument changes.","input":"The rune is roughly equivalent to with the exception that it will re-run whenever its argument changes. tracks reactive state deeply, meaning that updating something inside an object or array using fine-grained reactivity will cause it to re-fire ( ):","output":"<script>\nlet count = $state(0);\nlet message = $state('hello');\n\n$inspect(count, message); // will console.log when `count` or `message` change\n</script>\n\n<button onclick={() => count++}>Increment</button>\n<input bind:value={message} />"}
{"instruction":"Create a Svelte 5 component demonstrating $inspect: returns a property which you can invoke with a callback, which will then be invoked instead of .","input":"returns a property which you can invoke with a callback, which will then be invoked instead of . The first argument to the callback is either or subsequent arguments are the values passed to ( ):","output":"<script>\nlet count = $state(0);\n\n$inspect(count).with((type, count) => {\n  if (type === 'update') {\n    debugger; // or `console.trace`, or whatever you want\n  }\n});\n</script>\n\n<button onclick={() => count++}>Increment</button>"}
{"instruction":"Create a Svelte 5 component demonstrating $inspect.trace(...): This rune, added in 5.14, causes the surrounding function to be in development.","input":"This rune, added in 5.14, causes the surrounding function to be in development. Any time the function re-runs as part of an or a information will be printed to the console about which pieces of reactive state caused the effect to fire.","output":"<script>\nimport { doSomeWork } from './elsewhere';\n\n$effect(() => {\n  $inspect.trace();\n  doSomeWork();\n});\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating $host: When compiling a component as a the rune provides access to the host element, allowing you to (for example) dispatch custom events ( ):","input":"When compiling a component as a the rune provides access to the host element, allowing you to (for example) dispatch custom events ( ):","output":"<svelte:options customElement=\"my-stepper\" />\n\n<script>\nfunction dispatch(type) {\n  $host().dispatchEvent(new CustomEvent(type));\n}\n</script>\n\n<button onclick={() => dispatch('decrement')}>decrement</button>\n<button onclick={() => dispatch('increment')}>increment</button>"}
{"instruction":"Write Svelte 5 code for $host.","input":"","output":"<script>\nimport './Stepper.svelte';\n\nlet count = $state(0);\n</script>\n\n<my-stepper\n  ondecrement={() => count -= 1}\n  onincrement={() => count += 1}\n></my-stepper>\n\n<p>count: {count}</p>"}
{"instruction":"Create a Svelte 5 component demonstrating Basic markup: A lowercase tag, like denotes a regular HTML element.","input":"A lowercase tag, like denotes a regular HTML element. A capitalised tag or a tag that uses dot notation, such as or indicates a .","output":"<script>\nimport Widget from './Widget.svelte';\n</script>\n\n<div>\n  <Widget />\n</div>"}
{"instruction":"Create a Svelte 5 component demonstrating Basic markup: By default, attributes work exactly like their HTML counterparts.","input":"By default, attributes work exactly like their HTML counterparts.","output":"<div class=\"foo\">\n  <button disabled>can't touch this</button>\n</div>"}
{"instruction":"Create a Svelte 5 component demonstrating Basic markup: As in HTML, values may be unquoted.","input":"As in HTML, values may be unquoted.","output":"<input type=checkbox />"}
{"instruction":"Create a Svelte 5 component demonstrating Basic markup: Attribute values can contain JavaScript expressions.","input":"Attribute values can contain JavaScript expressions.","output":"<a href=\"page/{p}\">page {p}</a>"}
{"instruction":"Create a Svelte 5 component demonstrating Basic markup: Or they can JavaScript expressions.","input":"Or they can JavaScript expressions.","output":"<button disabled={!clickable}>...</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Basic markup: Boolean attributes are included on the element if their value is and excluded if it's .","input":"Boolean attributes are included on the element if their value is and excluded if it's . All other attributes are included unless their value is ( or ).","output":"<input required={false} placeholder=\"This input field is not required\" />\n<div title={null}>This div has no title attribute</div>"}
{"instruction":"Create a Svelte 5 component demonstrating Basic markup: When the attribute name and value match ( ) they can be replaced with .","input":"When the attribute name and value match ( ) they can be replaced with .","output":"<button {disabled}>...</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Basic markup: By convention, values passed to components are referred to as or rather than which are a feature of the DOM.","input":"By convention, values passed to components are referred to as or rather than which are a feature of the DOM. As with elements, can be replaced with the shorthand.","output":"<Widget foo={bar} answer={42} text=\"hello\" />"}
{"instruction":"Create a Svelte 5 component demonstrating Basic markup: allow many attributes or properties to be passed to an element or component at once.","input":"allow many attributes or properties to be passed to an element or component at once. An element or component can have multiple spread attributes, interspersed with regular ones.","output":"<Widget {...things} />"}
{"instruction":"Create a Svelte 5 component demonstrating Basic markup: Listening to DOM events is possible by adding attributes to the element that start with .","input":"Listening to DOM events is possible by adding attributes to the element that start with . For example, to listen to the event, add the attribute to a button:","output":"<button onclick={() => console.log('clicked')}>click me</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Basic markup: A JavaScript expression can be included as text by surrounding it with curly braces.","input":"A JavaScript expression can be included as text by surrounding it with curly braces.","output":"{expression}"}
{"instruction":"Create a Svelte 5 component demonstrating Basic markup: The expression will be stringified and escaped to prevent code injections.","input":"The expression will be stringified and escaped to prevent code injections. If you want to render HTML, use the tag instead.","output":"{@html potentiallyUnsafeHtmlString}"}
{"instruction":"Create a Svelte 5 component demonstrating Basic markup: You can use HTML comments inside components.","input":"You can use HTML comments inside components.","output":""}
{"instruction":"Create a Svelte 5 component demonstrating Basic markup: Comments beginning with disable warnings for the next block of markup.","input":"Comments beginning with disable warnings for the next block of markup. Usually, these are accessibility warnings; make sure that you're disabling them for a good reason.","output":"\n<input bind:value={name} autofocus />"}
{"instruction":"Create a Svelte 5 component demonstrating Basic markup: You can add a special comment starting with that will show up when hovering over the component name in other files.","input":"You can add a special comment starting with that will show up when hovering over the component name in other files.","output":"\n<script>\n  let { name } = $props();\n</script>\n\n<main>\n  <h1> Hello, {name} </h1>\n</main>"}
{"instruction":"Create a Svelte 5 component demonstrating {#if ...}: Content that is conditionally rendered can be wrapped in an if block.","input":"Content that is conditionally rendered can be wrapped in an if block.","output":"{#if answer === 42}\n  <p>what was the question?</p>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating {#if ...}: Additional conditions can be added with optionally ending in an clause.","input":"Additional conditions can be added with optionally ending in an clause.","output":"{#if porridge.temperature > 100}\n  <p>too hot!</p>\n{:else if 80 > porridge.temperature}\n  <p>too cold!</p>\n{:else}\n  <p>just right!</p>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating {#each ...}: Iterating over values can be done with an each block.","input":"Iterating over values can be done with an each block. The values in question can be arrays, array-like objects (i.e. anything with a property), or iterables like and â€” in other words, anything that can be used with .","output":"<h1>Shopping list</h1>\n<ul>\n  {#each items as item}\n    <li>{item.name} x {item.qty}</li>\n  {/each}\n</ul>"}
{"instruction":"Create a Svelte 5 component demonstrating {#each ...}: An each block can also specify an equivalent to the second argument in an callback:","input":"An each block can also specify an equivalent to the second argument in an callback:","output":"{#each items as item, i}\n  <li>{i + 1}: {item.name} x {item.qty}</li>\n{/each}"}
{"instruction":"Create a Svelte 5 component demonstrating {#each ...}: If a expression is provided â€” which must uniquely identify each list item â€” Svelte will use it to diff the list when data changes, rather than adding or removing items at the end.","input":"If a expression is provided â€” which must uniquely identify each list item â€” Svelte will use it to diff the list when data changes, rather than adding or removing items at the end. The key can be any object, but strings and numbers are recommended since they allow identity to persist when the objects themselves change.","output":"{#each items as item (item.id)}\n  <li>{item.name} x {item.qty}</li>\n{/each}\n\n{#each items as item, i (item.id)}\n  <li>{i + 1}: {item.name} x {item.qty}</li>\n{/each}"}
{"instruction":"Create a Svelte 5 component demonstrating {#each ...}: You can freely use destructuring and rest patterns in each blocks.","input":"You can freely use destructuring and rest patterns in each blocks.","output":"{#each items as { id, name, qty }, i (id)}\n  <li>{i + 1}: {name} x {qty}</li>\n{/each}\n\n{#each objects as { id, ...rest }}\n  <li><span>{id}</span><MyComponent {...rest} /></li>\n{/each}\n\n{#each items as [id, ...rest]}\n  <li><span>{id}</span><MyComponent values={rest} /></li>\n{/each}"}
{"instruction":"Create a Svelte 5 component demonstrating {#each ...}: In case you just want to render something times, you can omit the part ( ):","input":"In case you just want to render something times, you can omit the part ( ):","output":"<div class=\"chess-board\">\n  {#each { length: 8 }, rank}\n    {#each { length: 8 }, file}\n      <div class:black={(rank + file) % 2 === 1}></div>\n    {/each}\n  {/each}\n</div>"}
{"instruction":"Create a Svelte 5 component demonstrating {#each ...}: An each block can also have an clause, which is rendered if the list is empty.","input":"An each block can also have an clause, which is rendered if the list is empty.","output":"{#each todos as todo}\n  <p>{todo.text}</p>\n{:else}\n  <p>No tasks today!</p>\n{/each}"}
{"instruction":"Create a Svelte 5 component demonstrating {#key ...}: Key blocks destroy and recreate their contents when the value of an expression changes.","input":"Key blocks destroy and recreate their contents when the value of an expression changes. When used around components, this will cause them to be reinstantiated and reinitialised:","output":"{#key value}\n  <Component />\n{/key}"}
{"instruction":"Create a Svelte 5 component demonstrating {#key ...}: It's also useful if you want a transition to play whenever a value changes:","input":"It's also useful if you want a transition to play whenever a value changes:","output":"{#key value}\n  <div transition:fade>{value}</div>\n{/key}"}
{"instruction":"Create a Svelte 5 component demonstrating {#await ...}: Await blocks allow you to branch on the three possible states of a â€” pending, fulfilled or rejected.","input":"Await blocks allow you to branch on the three possible states of a â€” pending, fulfilled or rejected.","output":"{#await promise}\n  <p>waiting for the promise to resolve...</p>\n{:then value}\n  <p>The value is {value}</p>\n{:catch error}\n  <p>Something went wrong: {error.message}</p>\n{/await}"}
{"instruction":"Create a Svelte 5 component demonstrating {#await ...}: The block can be omitted if you don't need to render anything when the promise rejects (or no error is possible).","input":"The block can be omitted if you don't need to render anything when the promise rejects (or no error is possible).","output":"{#await promise}\n  <p>waiting for the promise to resolve...</p>\n{:then value}\n  <p>The value is {value}</p>\n{/await}"}
{"instruction":"Create a Svelte 5 component demonstrating {#await ...}: If you don't care about the pending state, you can also omit the initial block.","input":"If you don't care about the pending state, you can also omit the initial block.","output":"{#await promise then value}\n  <p>The value is {value}</p>\n{/await}"}
{"instruction":"Create a Svelte 5 component demonstrating {#await ...}: Similarly, if you only want to show the error state, you can omit the block.","input":"Similarly, if you only want to show the error state, you can omit the block.","output":"{#await promise catch error}\n  <p>The error is {error}</p>\n{/await}"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: Snippets, and are a way to create reusable chunks of markup inside your components.","input":"Snippets, and are a way to create reusable chunks of markup inside your components. Instead of writing duplicative code like ...","output":"{#snippet figure(image)}\n  <figure>\n    <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n    <figcaption>{image.caption}</figcaption>\n  </figure>\n{/snippet}\n\n{#each images as image}\n  {#if image.href}\n    <a href={image.href}>\n      {@render figure(image)}\n    </a>\n  {:else}\n    {@render figure(image)}\n  {/if}\n{/each}"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: Snippets can be declared anywhere inside your component.","input":"Snippets can be declared anywhere inside your component. They can reference values declared outside themselves, for example in the tag or in blocks ( )...","output":"<script>\nlet { message = `it's great to see you!` } = $props();\n</script>\n\n{#snippet hello(name)}\n  <p>hello {name}! {message}!</p>\n{/snippet}\n\n{@render hello('alice')}\n{@render hello('bob')}"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: ...and they are 'visible' to everything in the same lexical scope (i.e.","input":"...and they are 'visible' to everything in the same lexical scope (i.e. siblings, and children of those siblings):","output":"<div>\n  {#snippet x()}\n    {#snippet y()}...{/snippet}\n    {@render y()}\n  {/snippet}\n  {@render y()}\n</div>\n\n{@render x()}"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: Snippets can reference themselves and each other ( ):","input":"Snippets can reference themselves and each other ( ):","output":"{#snippet blastoff()}\n  <span>ðŸš€</span>\n{/snippet}\n\n{#snippet countdown(n)}\n  {#if n > 0}\n    <span>{n}...</span>\n    {@render countdown(n - 1)}\n  {:else}\n    {@render blastoff()}\n  {/if}\n{/snippet}\n\n{@render countdown(10)}"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: Within the template, snippets are values just like any other.","input":"Within the template, snippets are values just like any other. As such, they can be passed to components as props ( ):","output":"<script>\nimport Table from './Table.svelte';\n\nconst fruits = [\n  { name: 'apples', qty: 5, price: 2 },\n  { name: 'bananas', qty: 10, price: 1 },\n  { name: 'cherries', qty: 20, price: 0.5 }\n];\n</script>\n\n{#snippet header()}\n  <th>fruit</th>\n  <th>qty</th>\n  <th>price</th>\n  <th>total</th>\n{/snippet}\n\n{#snippet row(d)}\n  <td>{d.name}</td>\n  <td>{d.qty}</td>\n  <td>{d.price}</td>\n  <td>{d.qty * d.price}</td>\n{/snippet}\n\n<Table data={fruits} {header} {row} />"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: As an authoring convenience, snippets declared directly a component implicitly become props the component ( ):","input":"As an authoring convenience, snippets declared directly a component implicitly become props the component ( ):","output":"<Table data={fruits}>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n</Table>"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: Any content inside the component tags that is a snippet declaration implicitly becomes part of the snippet ( ):","input":"Any content inside the component tags that is a snippet declaration implicitly becomes part of the snippet ( ):","output":"<!file: App.svelte>\n<Button>click me</Button>"}
{"instruction":"Write Svelte 5 code for {#snippet ...}.","input":"","output":"<!file: Button.svelte>\n<script>\nlet { children } = $props();\n</script>\n\n<button>{@render children()}</button>"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: You can declare snippet props as being optional.","input":"You can declare snippet props as being optional. You can either use optional chaining to not render anything if the snippet isn't set...","output":"<script>\nlet { children } = $props();\n</script>\n\n{@render children?.()}"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: ...or use an block to render fallback content:","input":"...or use an block to render fallback content:","output":"<script>\nlet { children } = $props();\n</script>\n\n{#if children}\n  {@render children()}\n{:else}\n  fallback content\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: Snippets implement the interface imported from :","input":"Snippets implement the interface imported from :","output":"<script lang=\"ts\">\nimport type { Snippet } from 'svelte';\n\ninterface Props {\n  data: any[];\n  children: Snippet;\n  row: Snippet<[any]>;\n}\n\nlet { data, children, row }: Props = $props();\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: We can tighten things up further by declaring a generic, so that and refer to the same type:","input":"We can tighten things up further by declaring a generic, so that and refer to the same type:","output":"<script lang=\"ts\" generics=\"T\">\nimport type { Snippet } from 'svelte';\n\nlet {\n  data,\n  children,\n  row\n}: {\n  data: T[];\n  children: Snippet;\n  row: Snippet<[T]>;\n} = $props();\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: Snippets declared at the top level of a file can be exported from a for use in other components, provided they don't reference any declarations in a non-module (whether directly or indirectly, via other snippets) ( ):","input":"Snippets declared at the top level of a file can be exported from a for use in other components, provided they don't reference any declarations in a non-module (whether directly or indirectly, via other snippets) ( ):","output":"<script module>\nexport { add };\n</script>\n\n{#snippet add(a, b)}\n  {a} + {b} = {a + b}\n{/snippet}"}
{"instruction":"Create a Svelte 5 component demonstrating {@render ...}: To render a use a tag.","input":"To render a use a tag.","output":"{#snippet sum(a, b)}\n  <p>{a} + {b} = {a + b}</p>\n{/snippet}\n\n{@render sum(1, 2)}\n{@render sum(3, 4)}\n{@render sum(5, 6)}"}
{"instruction":"Create a Svelte 5 component demonstrating {@render ...}: The expression can be an identifier like or an arbitrary JavaScript expression:","input":"The expression can be an identifier like or an arbitrary JavaScript expression:","output":"{@render (cool ? coolSnippet : lameSnippet)()}"}
{"instruction":"Create a Svelte 5 component demonstrating {@render ...}: If the snippet is potentially undefined â€” for example, because it's an incoming prop â€” then you can use optional chaining to only render it when it defined:","input":"If the snippet is potentially undefined â€” for example, because it's an incoming prop â€” then you can use optional chaining to only render it when it defined:","output":"{@render children?.()}"}
{"instruction":"Create a Svelte 5 component demonstrating {@render ...}: Alternatively, use an block with an clause to render fallback content:","input":"Alternatively, use an block with an clause to render fallback content:","output":"{#if children}\n  {@render children()}\n{:else}\n  <p>fallback content</p>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating {@html ...}: To inject raw HTML into your component, use the tag:","input":"To inject raw HTML into your component, use the tag:","output":"<article>\n  {@html content}\n</article>"}
{"instruction":"Create a Svelte 5 component demonstrating {@html ...}: Content rendered this way is 'invisible' to Svelte and as such will not receive â€” in other words, this will not work, and the and styles will be regarded as unused:","input":"Content rendered this way is 'invisible' to Svelte and as such will not receive â€” in other words, this will not work, and the and styles will be regarded as unused:","output":"<article>\n  {@html content}\n</article>\n\n<style>\n  article {\n    a { color: hotpink }\n    img { width: 100% }\n  }\n</style>"}
{"instruction":"Create a Svelte 5 component demonstrating {@html ...}: Instead, use the modifier to target everything inside the :","input":"Instead, use the modifier to target everything inside the :","output":"<style>\n  article:global{\n    a { color: hotpink }\n    img { width: 100% }\n  }\n</style>"}
{"instruction":"Create a Svelte 5 component demonstrating {@const ...}: The tag defines a local constant.","input":"The tag defines a local constant.","output":"{#each boxes as box}\n  {@const area = box.width * box.height}\n  {box.width} * {box.height} = {area}\n{/each}"}
{"instruction":"Create a Svelte 5 component demonstrating {@debug ...}: The tag offers an alternative to .","input":"The tag offers an alternative to . It logs the values of specific variables whenever they change, and pauses code execution if you have devtools open.","output":"<script>\nlet user = {\n  firstname: 'Ada',\n  lastname: 'Lovelace'\n};\n</script>\n\n{@debug user}\n\n<h1>Hello {user.firstname}!</h1>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: Data ordinarily flows down, from parent to child.","input":"Data ordinarily flows down, from parent to child. The directive allows data to flow the other way, from child to parent. The general syntax is where is an (i.e. a variable or an object property). When the expression is an identifier with the same name as the property, we can omit the expression â€” in other words these are equivalent:","output":"<input bind:value={value} />\n<input bind:value />"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: You can also use where and are functions, allowing you to perform validation and transformation:","input":"You can also use where and are functions, allowing you to perform validation and transformation:","output":"<input bind:value={\n  () => value,\n  (v) => value = v.toLowerCase()\n} />"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: In the case of readonly bindings like the value should be :","input":"In the case of readonly bindings like the value should be :","output":"<div\n  bind:clientWidth={null, redraw}\n  bind:clientHeight={null, redraw}\n>\n  ...\n</div>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: A directive on an element binds the input's property:","input":"A directive on an element binds the input's property:","output":"<script>\nlet message = $state('hello');\n</script>\n\n<input bind:value={message} />\n<p>{message}</p>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: In the case of a numeric input ( or ) the value will be coerced to a number ( ):","input":"In the case of a numeric input ( or ) the value will be coerced to a number ( ):","output":"<script>\nlet a = $state(1);\nlet b = $state(2);\n</script>\n\n<label>\n  <input type=\"number\" bind:value={a} min=\"0\" max=\"10\" />\n  <input type=\"range\" bind:value={a} min=\"0\" max=\"10\" />\n</label>\n\n<label>\n  <input type=\"number\" bind:value={b} min=\"0\" max=\"10\" />\n  <input type=\"range\" bind:value={b} min=\"0\" max=\"10\" />\n</label>\n\n<p>{a} + {b} = {a + b}</p>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: Since 5.6.0, if an has a and is part of a form, it will revert to that value instead of the empty string when the form is reset.","input":"Since 5.6.0, if an has a and is part of a form, it will revert to that value instead of the empty string when the form is reset. Note that for the initial render the value of the binding takes precedence unless it is or .","output":"<script>\n  let value = $state('');\n</script>\n\n<form>\n  <input bind:value defaultValue=\"not the empty string\">\n  <input type=\"reset\" value=\"Reset\">\n</form>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: Checkbox and radio inputs can be bound with :","input":"Checkbox and radio inputs can be bound with :","output":"<label>\n  <input type=\"checkbox\" bind:checked={accepted} />\n  Accept terms and conditions\n</label>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: Since 5.6.0, if an has a attribute and is part of a form, it will revert to that value instead of when the form is reset.","input":"Since 5.6.0, if an has a attribute and is part of a form, it will revert to that value instead of when the form is reset. Note that for the initial render the value of the binding takes precedence unless it is or .","output":"<script>\n  let checked = $state(true);\n</script>\n\n<form>\n  <input type=\"checkbox\" bind:checked defaultChecked={true}>\n  <input type=\"reset\" value=\"Reset\">\n</form>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: Inputs that work together can use .","input":"Inputs that work together can use .","output":"<script>\nlet tortilla = $state('Plain');\n/** @type {Array<string>} */\nlet fillings = $state([]);\n</script>\n\n<input type=\"radio\" bind:group={tortilla} value=\"Plain\" />\n<input type=\"radio\" bind:group={tortilla} value=\"Whole wheat\" />\n<input type=\"radio\" bind:group={tortilla} value=\"Spinach\" />\n\n<input type=\"checkbox\" bind:group={fillings} value=\"Rice\" />\n<input type=\"checkbox\" bind:group={fillings} value=\"Beans\" />\n<input type=\"checkbox\" bind:group={fillings} value=\"Cheese\" />\n<input type=\"checkbox\" bind:group={fillings} value=\"Guac (extra)\" />"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: On elements with you can use to get the .","input":"On elements with you can use to get the . When you want to update the files programmatically, you always need to use a object. Currently objects cannot be constructed directly, so you need to create a new object and get from there.","output":"<script>\nlet files = $state();\n\nfunction clear() {\n  files = new DataTransfer().files; // null or undefined does not work\n}\n</script>\n\n<label for=\"avatar\">Upload a picture:</label>\n\n<input\n  accept=\"image/png, image/jpeg\"\n  bind:files\n  id=\"avatar\"\n  name=\"avatar\"\n  type=\"file\"\n/>\n\n<button onclick={clear}>clear</button>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: A value binding corresponds to the property on the selected which can be any value (not just strings, as is normally the case in the DOM).","input":"A value binding corresponds to the property on the selected which can be any value (not just strings, as is normally the case in the DOM).","output":"<select bind:value={selected}>\n  <option value={a}>a</option>\n  <option value={b}>b</option>\n  <option value={c}>c</option>\n</select>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: A element behaves similarly to a checkbox group.","input":"A element behaves similarly to a checkbox group. The bound variable is an array with an entry corresponding to the property of each selected .","output":"<select multiple bind:value={fillings}>\n  <option value=\"Rice\">Rice</option>\n  <option value=\"Beans\">Beans</option>\n  <option value=\"Cheese\">Cheese</option>\n  <option value=\"Guac (extra)\">Guac (extra)</option>\n</select>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: When the value of an matches its text content, the attribute can be omitted.","input":"When the value of an matches its text content, the attribute can be omitted.","output":"<select multiple bind:value={fillings}>\n  <option>Rice</option>\n  <option>Beans</option>\n  <option>Cheese</option>\n  <option>Guac (extra)</option>\n</select>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: You can give the a default value by adding a attribute to the (or options, in the case of ) that should be initially selected.","input":"You can give the a default value by adding a attribute to the (or options, in the case of ) that should be initially selected. If the is part of a form, it will revert to that selection when the form is reset. Note that for the initial render the value of the binding takes precedence if it's not .","output":"<select bind:value={selected}>\n  <option value={a}>a</option>\n  <option value={b} selected>b</option>\n  <option value={c}>c</option>\n</select>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: elements have their own set of bindings â€” five two-way ones...","input":"elements have their own set of bindings â€” five two-way ones...","output":"<audio\n  src={clip}\n  bind:duration\n  bind:currentTime\n  bind:paused\n></audio>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: elements have all the same bindings as elements, plus readonly and bindings.","input":"elements have all the same bindings as elements, plus readonly and bindings.","output":""}
{"instruction":"Create a Svelte 5 component demonstrating bind:: elements have two readonly bindings:","input":"elements have two readonly bindings:","output":""}
{"instruction":"Create a Svelte 5 component demonstrating bind:: elements support binding to the property.","input":"elements support binding to the property.","output":"<details bind:open={isOpen}>\n  <summary>How do you comfort a JavaScript bug?</summary>\n  <p>You console it.</p>\n</details>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: Elements with the attribute support the following bindings:","input":"Elements with the attribute support the following bindings:","output":"<div contenteditable=\"true\" bind:innerHTML={html}></div>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: All visible elements have the following readonly bindings, measured with a :","input":"All visible elements have the following readonly bindings, measured with a :","output":"<div bind:offsetWidth={width} bind:offsetHeight={height}>\n  <Chart {width} {height} />\n</div>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: To get a reference to a DOM node, use .","input":"To get a reference to a DOM node, use . The value will be until the component is mounted â€” in other words, you should read it inside an effect or an event handler, but not during component initialisation:","output":"<script>\n/** @type {HTMLCanvasElement} */\nlet canvas;\n\n$effect(() => {\n  const ctx = canvas.getContext('2d');\n  drawStuff(ctx);\n});\n</script>\n\n<canvas bind:this={canvas}></canvas>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: Components also support allowing you to interact with component instances programmatically.","input":"Components also support allowing you to interact with component instances programmatically.","output":"<!file: App.svelte>\n<ShoppingCart bind:this={cart} />\n\n<button onclick={() => cart.empty()}>\n  Empty shopping cart\n</button>"}
{"instruction":"Write Svelte 5 code for bind:.","input":"","output":"<!file: ShoppingCart.svelte>\n<script>\n// All instance exports are available on the instance object\nexport function empty() {\n  // ...\n}\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: You can bind to component props using the same syntax as for elements.","input":"You can bind to component props using the same syntax as for elements.","output":"<Keypad bind:value={pin} />"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: While Svelte props are reactive without binding, that reactivity only flows downward into the component by default.","input":"While Svelte props are reactive without binding, that reactivity only flows downward into the component by default. Using allows changes to the property from within the component to flow back up out of the component. To mark a property as bindable, use the rune:","output":"<script>\nlet { readonlyProperty, bindableProperty = $bindable() } = $props();\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: Bindable properties can have a fallback value:","input":"Bindable properties can have a fallback value:","output":"<script>\nlet { bindableProperty = $bindable('fallback value') } = $props();\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating use:: Actions are functions that are called when an element is mounted.","input":"Actions are functions that are called when an element is mounted. They are added with the directive, and will typically use an so that they can reset any state when the element is unmounted:","output":"<!file: App.svelte>\n<script>\n/** @type {import('svelte/action').Action} */\nfunction myaction(node) {\n  // the node has been mounted in the DOM\n\n  $effect(() => {\n    // setup goes here\n\n    return () => {\n      // teardown goes here\n    };\n  });\n}\n</script>\n\n<div use:myaction>...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating use:: An action can be called with an argument:","input":"An action can be called with an argument:","output":"<!file: App.svelte>\n<script>\n/** @type {import('svelte/action').Action} */\nfunction myaction(node,data) {\n  // ...\n}\n</script>\n\n<div use:myaction={data}>...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating use:: The interface receives three optional type arguments â€” a node type (which can be if the action applies to everything), a parameter, and any custom event handlers created by the action:","input":"The interface receives three optional type arguments â€” a node type (which can be if the action applies to everything), a parameter, and any custom event handlers created by the action:","output":"<!file: App.svelte>\n<script>\n/**\n * @type {import('svelte/action').Action<\n * HTMLDivElement,\n * undefined,\n * {\n * onswiperight: (e: CustomEvent) => void;\n * onswipeleft: (e: CustomEvent) => void;\n * // ...\n * }\n * >}\n */\nfunction gestures(node) {\n  $effect(() => {\n    // ...\n    node.dispatchEvent(new CustomEvent('swipeleft'));\n    // ...\n    node.dispatchEvent(new CustomEvent('swiperight'));\n  });\n}\n</script>\n\n<div use:gestures onswipeleft={next} onswiperight={prev}>\n  ...\n</div>"}
{"instruction":"Create a Svelte 5 component demonstrating transition:: A is triggered by an element entering or leaving the DOM as a result of a state change.","input":"A is triggered by an element entering or leaving the DOM as a result of a state change. When a block (such as an block) is transitioning out, all elements inside it, including those that do not have their own transitions, are kept in the DOM until every transition in the block has been completed. The directive indicates a transition, which means it can be smoothly reversed while the transition is in progress.","output":"<script>\nimport { fade } from 'svelte/transition';\n\nlet visible = $state(false);\n</script>\n\n<button onclick={() => visible = !visible}>toggle</button>\n\n{#if visible}\n  <divtransition:fade>fades in and out</div>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating transition:: Transitions are local by default.","input":"Transitions are local by default. Local transitions only play when the block they belong to is created or destroyed, when parent blocks are created or destroyed.","output":"{#if x}\n  {#if y}\n    <p transition:fade>fades in and out only when y changes</p>\n    <p transition:fade|global>fades in and out when x or y change</p>\n  {/if}\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating transition:: Transitions can have parameters.","input":"Transitions can have parameters. (The double aren't a special syntax; this is an object literal inside an expression tag.)","output":"{#if visible}\n  <div transition:fade={{ duration: 2000 }}>fades in and out over two seconds</div>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating transition:: Transitions can use custom functions.","input":"Transitions can use custom functions. If the returned object has a function, Svelte will generate keyframes for a . The argument passed to is a value between and after the function has been applied. transitions run from to transitions run from to â€” in other words, is the element's natural state, as though no transition had been applied. The argument is equal to . The function is called repeatedly the transition begins, with different and arguments.","output":"<!file: App.svelte>\n<script>\nimport { elasticOut } from 'svelte/easing';\n\n/** @type {boolean} */\nexport let visible;\n\n/**\n * @param {HTMLElement} node\n * @param {{ delay?: number, duration?: number, easing?: (t: number) => number }} params\n */\nfunction whoosh(node, params) {\n  const existingTransform = getComputedStyle(node).transform.replace('none', '');\n\n  return {\n    delay: params.delay || 0,\n    duration: params.duration || 400,\n    easing: params.easing || elasticOut,\n    css: (t, u) => `transform: ${existingTransform} scale(${t})`\n  };\n}\n</script>\n\n{#if visible}\n  <div in:whoosh>whooshes in</div>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating transition:: A custom transition function can also return a function, which is called the transition with the same and arguments.","input":"A custom transition function can also return a function, which is called the transition with the same and arguments.","output":"<!file: App.svelte>\n<script>\nexport let visible = false;\n\n/**\n * @param {HTMLElement} node\n * @param {{ speed?: number }} params\n */\nfunction typewriter(node, { speed = 1 }) {\n  const valid =\n    node.childNodes.length === 1 &&\n    node.childNodes[0].nodeType === Node.TEXT_NODE;\n\n  if (!valid) {\n    throw new Error(\n      `This transition only works on elements with a single text node child`\n    );\n  }\n\n  const text = node.textContent;\n  const duration = text.length / (speed * 0.01);\n\n  return {\n    duration,\n    tick: (t) => {\n      const i = ~~(text.length * t);\n      node.textContent = text.slice(0, i);\n    }\n  };\n}\n</script>\n\n{#if visible}\n  <p in:typewriter={{ speed: 1 }}>The quick brown fox jumps over the lazy dog</p>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating transition:: An element with transitions will dispatch the following events in addition to any standard DOM events:","input":"An element with transitions will dispatch the following events in addition to any standard DOM events:","output":"{#if visible}\n  <p\n    transition:fly={{ y: 200, duration: 2000 }}\n    onintrostart={() => (status = 'intro started')}\n    onoutrostart={() => (status = 'outro started')}\n    onintroend={() => (status = 'intro ended')}\n    onoutroend={() => (status = 'outro ended')}\n  >\n    Flies in and out\n  </p>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating in: and out:: The and directives are identical to except that the resulting transitions are not bidirectional â€” an transition will continue to 'play' alongside the transition, rather than reversing, if the block is outroed while the transition is in progress.","input":"The and directives are identical to except that the resulting transitions are not bidirectional â€” an transition will continue to 'play' alongside the transition, rather than reversing, if the block is outroed while the transition is in progress. If an out transition is aborted, transitions will restart from scratch.","output":"<script>\nimport { fade, fly } from 'svelte/transition';\n\nlet visible = $state(false);\n</script>\n\n<label>\n  <input type=\"checkbox\" bind:checked={visible}>\n  visible\n</label>\n\n{#if visible}\n  <div in:fly={{ y: 200 }} out:fade>flies in, fades out</div>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating animate:: An animation is triggered when the contents of a are re-ordered.","input":"An animation is triggered when the contents of a are re-ordered. Animations do not run when an element is added or removed, only when the index of an existing data item within the each block changes. Animate directives must be on an element that is an child of a keyed each block. Animations can be used with Svelte's or .","output":"{#each list as item, index (item)}\n  <li animate:flip>{item}</li>\n{/each}"}
{"instruction":"Create a Svelte 5 component demonstrating animate:: As with actions and transitions, animations can have parameters.","input":"As with actions and transitions, animations can have parameters. (The double aren't a special syntax; this is an object literal inside an expression tag.)","output":"{#each list as item, index (item)}\n  <li animate:flip={{ delay: 500 }}>{item}</li>\n{/each}"}
{"instruction":"Create a Svelte 5 component demonstrating animate:: Animations can use custom functions that provide the an object and any as arguments.","input":"Animations can use custom functions that provide the an object and any as arguments. The parameter is an object containing and properties each containing a describing the geometry of the element in its and positions. The property is the DOMRect of the element in its starting position, and the property is the DOMRect of the element in its final position after the list has been reordered and the DOM updated. If the returned object has a method, Svelte will create a that plays on the element. The argument passed to is a value that goes from and after the function has been applied. The argument is equal to . The function is called repeatedly the animation begins, with different and arguments.","output":"<!file: App.svelte>\n<script>\nimport { cubicOut } from 'svelte/easing';\n\n/**\n * @param {HTMLElement} node\n * @param {{ from: DOMRect; to: DOMRect }} states\n * @param {any} params\n */\nfunction whizz(node, { from, to }, params) {\n  const dx = from.left - to.left;\n  const dy = from.top - to.top;\n\n  const d = Math.sqrt(dx * dx + dy * dy);\n\n  return {\n    delay: 0,\n    duration: Math.sqrt(d) * 120,\n    easing: cubicOut,\n    css: (t, u) => `transform: translate(${u * dx}px, ${u * dy}px) rotate(${t * 360}deg);`\n  };\n}\n</script>\n\n{#each list as item, index (item)}\n  <div animate:whizz>{item}</div>\n{/each}"}
{"instruction":"Create a Svelte 5 component demonstrating animate:: A custom animation function can also return a function, which is called the animation with the same and arguments.","input":"A custom animation function can also return a function, which is called the animation with the same and arguments.","output":"<!file: App.svelte>\n<script>\nimport { cubicOut } from 'svelte/easing';\n\n/**\n * @param {HTMLElement} node\n * @param {{ from: DOMRect; to: DOMRect }} states\n * @param {any} params\n */\nfunction whizz(node, { from, to }, params) {\n  const dx = from.left - to.left;\n  const dy = from.top - to.top;\n\n  const d = Math.sqrt(dx * dx + dy * dy);\n\n  return {\n    delay: 0,\n    duration: Math.sqrt(d) * 120,\n    easing: cubicOut,\n    tick: (t, u) => Object.assign(node.style, { color: t > 0.5 ? 'Pink' : 'Blue' })\n  };\n}\n</script>\n\n{#each list as item, index (item)}\n  <div animate:whizz>{item}</div>\n{/each}"}
{"instruction":"Create a Svelte 5 component demonstrating style:: The directive provides a shorthand for setting multiple styles on an element.","input":"The directive provides a shorthand for setting multiple styles on an element.","output":"<div style:color=\"red\">...</div>\n\n<div style=\"color: red;\">...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating style:: The value can contain arbitrary expressions:","input":"The value can contain arbitrary expressions:","output":"<div style:color={myColor}>...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating style:: The shorthand form is allowed:","input":"The shorthand form is allowed:","output":"<div style:color>...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating style:: Multiple styles can be set on a single element:","input":"Multiple styles can be set on a single element:","output":"<div style:color style:width=\"12rem\" style:background-color={darkMode ? 'black' : 'white'}>...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating style:: To mark a style as important, use the modifier:","input":"To mark a style as important, use the modifier:","output":"<div style:color|important=\"red\">...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating style:: When directives are combined with attributes, the directives will take precedence:","input":"When directives are combined with attributes, the directives will take precedence:","output":"<div style=\"color: blue;\" style:color=\"red\">This will be red</div>"}
{"instruction":"Create a Svelte 5 component demonstrating class: Primitive values are treated like any other attribute:","input":"Primitive values are treated like any other attribute:","output":"<div class={large ? 'large' : 'small'}>...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating class: If the value is an object, the truthy keys are added:","input":"If the value is an object, the truthy keys are added:","output":"<script>\nlet { cool } = $props();\n</script>\n\n<div class={{ cool, lame: !cool }}>...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating class: If the value is an array, the truthy values are combined:","input":"If the value is an array, the truthy values are combined:","output":"<div class={[faded && 'saturate-0 opacity-50', large && 'scale-200']}>...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating class: Arrays can contain arrays and objects, and clsx will flatten them.","input":"Arrays can contain arrays and objects, and clsx will flatten them. This is useful for combining local classes with props, for example:","output":"<!file: Button.svelte>\n<script>\nlet props = $props();\n</script>\n\n<button {...props} class={['cool-button', props.class]}>\n  {@render props.children?.()}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating class: The user of this component has the same flexibility to use a mixture of objects, arrays and strings:","input":"The user of this component has the same flexibility to use a mixture of objects, arrays and strings:","output":"<!file: App.svelte>\n<script>\nimport Button from './Button.svelte';\n\nlet useTailwind = $state(false);\n</script>\n\n<Button\n  onclick={() => useTailwind = true}\n  class={{ 'bg-blue-700 sm:w-1/2': useTailwind }}\n>\n  Accept the inevitability of Tailwind\n</Button>"}
{"instruction":"Create a Svelte 5 component demonstrating class: Svelte also exposes the type, which is the type of value that the attribute on elements accept.","input":"Svelte also exposes the type, which is the type of value that the attribute on elements accept. This is useful if you want to use a type-safe class name in component props:","output":"<script lang=\"ts\">\nimport type { ClassValue } from 'svelte/elements';\n\nconst props: { class: ClassValue } = $props();\n</script>\n\n<div class={['original', props.class]}>...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating class: Prior to Svelte 5.16, the directive was the most convenient way to set classes on elements conditionally.","input":"Prior to Svelte 5.16, the directive was the most convenient way to set classes on elements conditionally.","output":"<div class={{ cool, lame: !cool }}>...</div>\n\n<div class:cool={cool} class:lame={!cool}>...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating class: As with other directives, we can use a shorthand when the name of the class coincides with the value:","input":"As with other directives, we can use a shorthand when the name of the class coincides with the value:","output":"<div class:cool class:lame={!cool}>...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating Scoped styles: Svelte components can include a element containing CSS that belongs to the component.","input":"Svelte components can include a element containing CSS that belongs to the component. This CSS is by default, meaning that styles will not apply to any elements on the page outside the component in question. This works by adding a class to affected elements, which is based on a hash of the component styles (e.g. ).","output":"<style>\np {\n  /* this will only affect <p> elements in this component */\n  color: burlywood;\n}\n</style>"}
{"instruction":"Create a Svelte 5 component demonstrating Scoped styles: If a component defines the name is scoped to the component using the same hashing approach.","input":"If a component defines the name is scoped to the component using the same hashing approach. Any rules in the component will be similarly adjusted:","output":"<style>\n.bouncy {\n  animation: bounce 10s;\n}\n\n/* these keyframes are only accessible inside this component */\n@keyframes bounce {\n  /* ... */\n}\n</style>"}
{"instruction":"Create a Svelte 5 component demonstrating Global styles: To apply styles to a single selector globally, use the modifier:","input":"To apply styles to a single selector globally, use the modifier:","output":"<style>\n:global(body) {\n  /* applies to <body> */\n  margin: 0;\n}\n\ndiv :global(strong) {\n  /* applies to all <strong> elements, in any component,\n     that are inside <div> elements belonging to this component */\n  color: goldenrod;\n}\n\np:global(.big.red) {\n  /* applies to all <p> elements belonging to this component with `class=\"big red\"`,\n     even if it is applied programmatically (for example by a library) */\n}\n</style>"}
{"instruction":"Create a Svelte 5 component demonstrating Global styles: If you want to make @keyframes that are accessible globally, you need to prepend your keyframe names with .","input":"If you want to make @keyframes that are accessible globally, you need to prepend your keyframe names with . The part will be removed when compiled, and the keyframe will then be referenced using just elsewhere in your code.","output":"<style>\n@keyframes -global-my-animation-name {\n  /* code goes here */\n}\n</style>"}
{"instruction":"Create a Svelte 5 component demonstrating Global styles: To apply styles to a group of selectors globally, create a block:","input":"To apply styles to a group of selectors globally, create a block:","output":"<style>\n:global {\n  /* applies to every <div> in your application */\n  div { ... }\n\n  /* applies to every <p> in your application */\n  p { ... }\n}\n\n.a :global {\n  /* applies to every `.b .c .d` element, in any component,\n     that is inside an `.a` element in this component */\n  .b .c .d {...}\n}\n</style>"}
{"instruction":"Create a Svelte 5 component demonstrating Custom properties: You can pass CSS custom properties â€” both static and dynamic â€” to components:","input":"You can pass CSS custom properties â€” both static and dynamic â€” to components:","output":"<Slider\n  bind:value\n  min={0}\n  max={100}\n  --track-color=\"black\"\n  --thumb-color=\"rgb({r} {g} {b})\"\n/>"}
{"instruction":"Create a Svelte 5 component demonstrating Custom properties: Inside the component, we can read these custom properties (and provide fallback values) using :","input":"Inside the component, we can read these custom properties (and provide fallback values) using :","output":"<style>\n.track {\n  background: var(--track-color, #aaa);\n}\n\n.thumb {\n  background: var(--thumb-color, blue);\n}\n</style>"}
{"instruction":"Create a Svelte 5 component demonstrating Nested <style> elements: There can only be one top-level tag per component.","input":"There can only be one top-level tag per component. However, it is possible to have a tag nested inside other elements or logic blocks. In that case, the tag will be inserted as-is into the DOM; no scoping or processing will be done on the tag.","output":"<div>\n  <style>\n    /* this style tag will be inserted as-is */\n    div {\n      /* this will apply to all `<div>` elements in the DOM */\n      color: red;\n    }\n  </style>\n</div>"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:boundary>: Boundaries allow you to guard against errors in part of your app from breaking the app as a whole, and to recover from those errors.","input":"Boundaries allow you to guard against errors in part of your app from breaking the app as a whole, and to recover from those errors. If an error occurs while rendering or updating the children of a or running any functions contained therein, the contents will be removed. Errors occurring outside the rendering process (for example, in event handlers or after a or async work) are caught by error boundaries.","output":"<svelte:boundary onerror={handler}>...</svelte:boundary>"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:boundary>: If a snippet is provided, it will be rendered with the error that was thrown, and a function that recreates the contents ( ):","input":"If a snippet is provided, it will be rendered with the error that was thrown, and a function that recreates the contents ( ):","output":"<svelte:boundary>\n  <FlakyComponent />\n\n  {#snippet failed(error, reset)}\n    <button onclick={reset}>oops! try again</button>\n  {/snippet}\n</svelte:boundary>"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:boundary>: If an function is provided, it will be called with the same two and arguments.","input":"If an function is provided, it will be called with the same two and arguments. This is useful for tracking the error with an error reporting service...","output":"<svelte:boundary onerror={(e) => report(e)}>\n  ...\n</svelte:boundary>"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:boundary>: ...or using and outside the boundary itself:","input":"...or using and outside the boundary itself:","output":"<script>\nlet error = $state(null);\nlet reset = $state(() => {});\n\nfunction onerror(e, r) {\n  error = e;\n  reset = r;\n}\n</script>\n\n<svelte:boundary {onerror}>\n  <FlakyComponent />\n</svelte:boundary>\n\n{#if error}\n  <button onclick={() => {\n    error = null;\n    reset();\n  }}>\n    oops! try again\n  </button>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:window>: The element allows you to add event listeners to the object without worrying about removing them when the component is destroyed, or checking for the existence of when server-side rendering.","input":"The element allows you to add event listeners to the object without worrying about removing them when the component is destroyed, or checking for the existence of when server-side rendering. This element may only appear at the top level of your component â€” it cannot be inside a block or element.","output":"<script>\nfunction handleKeydown(event) {\n  alert(`pressed the ${event.key} key`);\n}\n</script>\n\n<svelte:window onkeydown={handleKeydown} />"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:window>: You can also bind to the following properties:","input":"You can also bind to the following properties:","output":"<svelte:window bind:scrollY={y} />"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:document>: Similarly to this element allows you to add listeners to events on such as which don't fire on .","input":"Similarly to this element allows you to add listeners to events on such as which don't fire on . It also lets you use on . As with this element may only appear the top level of your component and must never be inside a block or element.","output":"<svelte:document onvisibilitychange={handleVisibilityChange} use:someAction />"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:body>: Similarly to this element allows you to add listeners to events on such as and which don't fire on .","input":"Similarly to this element allows you to add listeners to events on such as and which don't fire on . It also lets you use on the element. As with and this element may only appear the top level of your component and must never be inside a block or element.","output":"<svelte:body\n  onmouseenter={handleMouseenter}\n  onmouseleave={handleMouseleave}\n  use:someAction\n/>"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:head>: This element makes it possible to insert elements into .","input":"This element makes it possible to insert elements into . During server-side rendering, content is exposed separately to the main content. As with and this element may only appear at the top level of your component and must never be inside a block or element.","output":"<svelte:head>\n  <title>Hello world!</title>\n  <meta name=\"description\" content=\"This is where the description goes for SEO\" />\n</svelte:head>"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:element>: The element lets you render an element that is unknown at author time, for example because it comes from a CMS.","input":"The element lets you render an element that is unknown at author time, for example because it comes from a CMS. Any properties and event listeners present will be applied to the element. The only supported binding is since Svelte's built-in bindings do not work with generic elements. If has a nullish value, the element and its children will not be rendered. If is the name of a (e.g., ) and has child elements, a runtime error will be thrown in development mode:","output":"<script>\nlet tag = $state('hr');\n</script>\n\n<svelte:element this={tag}>\n  This text cannot appear inside an hr element\n</svelte:element>"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:element>: Svelte tries its best to infer the correct namespace from the element's surroundings, but it's not always possible.","input":"Svelte tries its best to infer the correct namespace from the element's surroundings, but it's not always possible. You can make it explicit with an attribute:","output":"<svelte:element this={tag} xmlns=\"http://www.w3.org/2000/svg\" />"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:options>: The element provides a place to specify per-component compiler options, which are detailed in the .","input":"The element provides a place to specify per-component compiler options, which are detailed in the . The possible options are:","output":"<svelte:options customElement=\"my-custom-element\" />"}
{"instruction":"Create a Svelte 5 component demonstrating Stores: A is an object that allows reactive access to a value via a simple .","input":"A is an object that allows reactive access to a value via a simple . The module contains minimal store implementations which fulfil this contract. Any time you have a reference to a store, you can access its value inside a component by prefixing it with the character. This causes Svelte to declare the prefixed variable, subscribe to the store at component initialisation and unsubscribe when appropriate. Assignments to -prefixed variables require that the variable be a writable store, and will result in a call to the store's method. Note that the store must be declared at the top level of the component â€” not inside an block or a function, for example. Local variables (that do not represent store values) must have a prefix.","output":"<script>\nimport { writable } from 'svelte/store';\n\nconst count = writable(0);\n\nconsole.log($count); // logs 0\n\ncount.set(1);\nconsole.log($count); // logs 1\n\n$count = 2;\nconsole.log($count); // logs 2\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Stores: - when creating shared state, you can create a object containing the values you need and then manipulate said state","input":"- when creating shared state, you can create a object containing the values you need and then manipulate said state","output":"<script>\nimport { userState } from './state.svelte.js';\n</script>\n\n<p>User name: {userState.name}</p>\n\n<button onclick={() => { userState.name = 'new name'; }}>\n  change name\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Context: Context allows components to access values owned by parent components without passing them down as props (potentially through many layers of intermediate components, known as 'prop-drilling').","input":"Context allows components to access values owned by parent components without passing them down as props (potentially through many layers of intermediate components, known as 'prop-drilling'). The parent component sets context with ...","output":"<!file: Parent.svelte>\n<script>\nimport { setContext } from 'svelte';\n\nsetContext('my-context', 'hello from Parent.svelte');\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Context: ...and the child retrieves it with :","input":"...and the child retrieves it with :","output":"<!file: Child.svelte>\n<script>\nimport { getContext } from 'svelte';\n\nconst message = getContext('my-context');\n</script>\n\n<h1>{message}, inside Child.svelte</h1>"}
{"instruction":"Create a Svelte 5 component demonstrating Context: This is particularly useful when is not directly aware of but instead renders it as part of a ( ):","input":"This is particularly useful when is not directly aware of but instead renders it as part of a ( ):","output":"<Parent>\n  <Child />\n</Parent>"}
{"instruction":"Create a Svelte 5 component demonstrating Context: You can store reactive state in context ( )...","input":"You can store reactive state in context ( )...","output":"<script>\nimport { setContext } from 'svelte';\nimport Child from './Child.svelte';\n\nlet counter = $state({ count: 0 });\nsetContext('counter', counter);\n</script>\n\n<button onclick={() => counter.count += 1}>\n  increment\n</button>\n\n<Child />\n<Child />\n<Child />"}
{"instruction":"Create a Svelte 5 component demonstrating Context: ...though note that if you instead of updating it, you will 'break the link' â€” in other words instead of this...","input":"...though note that if you instead of updating it, you will 'break the link' â€” in other words instead of this...","output":"<button onclick={() => counter = { count: 0 }}>\n  reset\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Context: ...you must do this:","input":"...you must do this:","output":"<button onclick={() =>counter.count = 0}>\n  reset\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Context: ...then the data may be accessible by the user.","input":"...then the data may be accessible by the user. Context solves this problem because it is not shared between requests.","output":"<!file: App.svelte->\n<script>\nimport { myGlobalState } from 'svelte';\n\nlet { data } = $props();\n\nif (data.user) {\n  myGlobalState.user = data.user;\n}\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Lifecycle hooks: The function schedules a callback to run as soon as the component has been mounted to the DOM.","input":"The function schedules a callback to run as soon as the component has been mounted to the DOM. It must be called during the component's initialisation (but doesn't need to live the component; it can be called from an external module). does not run inside a component that is rendered on the server.","output":"<script>\nimport { onMount } from 'svelte';\n\nonMount(() => {\n  console.log('the component has mounted');\n});\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Lifecycle hooks: If a function is returned from it will be called when the component is unmounted.","input":"If a function is returned from it will be called when the component is unmounted.","output":"<script>\nimport { onMount } from 'svelte';\n\nonMount(() => {\n  const interval = setInterval(() => {\n    console.log('beep');\n  }, 1000);\n\n  return () => clearInterval(interval);\n});\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Lifecycle hooks: Schedules a callback to run immediately before the component is unmounted.","input":"Schedules a callback to run immediately before the component is unmounted. Out of and this is the only one that runs inside a server-side component.","output":"<script>\nimport { onDestroy } from 'svelte';\n\nonDestroy(() => {\n  console.log('the component is being destroyed');\n});\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Lifecycle hooks: While there's no \"after update\" hook, you can use to ensure that the UI is updated before continuing.","input":"While there's no \"after update\" hook, you can use to ensure that the UI is updated before continuing. returns a promise that resolves once any pending state changes have been applied, or in the next microtask if there are none.","output":"<script>\nimport { tick } from 'svelte';\n\n$effect.pre(() => {\n  console.log('the component is about to update');\n  tick().then(() => {\n    console.log('the component just updated');\n  });\n});\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Lifecycle hooks: Svelte 4 contained hooks that ran before and after the component as a whole was updated.","input":"Svelte 4 contained hooks that ran before and after the component as a whole was updated. For backwards compatibility, these hooks were shimmed in Svelte 5 but not available inside components that use runes.","output":"<script>\nimport { beforeUpdate, afterUpdate } from 'svelte';\n\nbeforeUpdate(() => {\n  console.log('the component is about to update');\n});\n\nafterUpdate(() => {\n  console.log('the component just updated');\n});\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Lifecycle hooks: To implement a chat window that autoscrolls to the bottom when new messages appear (but only if you were scrolled to the bottom), we need to measure the DOM before we update it.","input":"To implement a chat window that autoscrolls to the bottom when new messages appear (but only if you were scrolled to the bottom), we need to measure the DOM before we update it. In Svelte 4, we do this with but this is a flawed approach â€” it fires before update, whether it's relevant or not. In the example below, we need to introduce checks like to make sure we don't mess with the scroll position when someone toggles dark mode. With runes, we can use which behaves the same as but runs before the DOM is updated. As long as we explicitly reference inside the effect body, it will run whenever changes, but when changes. and its equally troublesome counterpart are therefore deprecated in Svelte 5.","output":"<script>\nimport {beforeUpdate, afterUpdate,tick } from 'svelte';\n\nlet updatingMessages = false;\nlet theme =$state('dark');\nlet messages =$state([]);\nlet viewport;\n\nbeforeUpdate(() => {\n$effect.pre(() => {\n  if (!updatingMessages) return;\n  messages;\n\n  const autoscroll =\n    viewport &&\n    viewport.offsetHeight + viewport.scrollTop > viewport.scrollHeight - 50;\n\n  if (autoscroll) {\n    tick().then(() => {\n      viewport.scrollTo(0, viewport.scrollHeight);\n    });\n  }\n  updatingMessages = false;\n});\n\nfunction handleKeydown(event) {\n  if (event.key === 'Enter') {\n    const text = event.target.value;\n    if (!text) return;\n\n    updatingMessages = true;\n    messages = [...messages, text];\n    event.target.value = '';\n  }\n}\n\nfunction toggle() {\n  theme = theme === 'dark' ? 'light' : 'dark';\n}\n</script>\n\n<div class:dark={theme === 'dark'}>\n  <div bind:this={viewport}>\n    {#each messages as message}\n      <p>{message}</p>\n    {/each}\n  </div>\n\n  <inputonkeydown={handleKeydown} />\n  <buttononclick={toggle}>\n    Toggle dark mode\n  </button>\n</div>"}
{"instruction":"Write Svelte 5 code for Overview.","input":"Svelte 5 introduced some significant changes to Svelte's API, including and event attributes. As a result, some Svelte 3/4 features are deprecated (though supported for now, unless otherwise specified) and will eventually be removed. We recommend that you incrementally . The following pages document these features for","output":""}
{"instruction":"Create a Svelte 5 component demonstrating Reactive let/var declarations: In runes mode, reactive state is explicitly declared with the .","input":"In runes mode, reactive state is explicitly declared with the . In legacy mode, variables declared at the top level of a component are automatically considered . Reassigning or mutating these variables ( or ) will cause the UI to update.","output":"<script>\nlet count = 0;\n</script>\n\n<button on:click={() => count += 1}>\n  clicks: {count}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Reactive let/var declarations: Because Svelte's legacy mode reactivity is based on using array methods like .","input":"Because Svelte's legacy mode reactivity is based on using array methods like . and . won't automatically trigger updates. A subsequent assignment is required to 'tell' the compiler to update the UI:","output":"<script>\nlet numbers = [1, 2, 3, 4];\n\nfunction addNumber() {\n  // this method call does not trigger an update\n  numbers.push(numbers.length + 1);\n\n  // this assignment will update anything\n  // that depends on `numbers`\n  numbers = numbers;\n}\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Reactive $: statements: In runes mode, reactions to state updates are handled with the and runes.","input":"In runes mode, reactions to state updates are handled with the and runes. In legacy mode, any top-level statement (i.e. not inside a block or a function) can be made reactive by prefixing it with a . These statements run after other code in the and before the component markup is rendered, then whenever the values that they depend on change.","output":"<script>\nlet a = 1;\nlet b = 2;\n\n// this is a 'reactive statement', and it will re-run\n// when `a`, `b` or `sum` change\n$: console.log(`${a} + ${b} = ${sum}`);\n\n// this is a 'reactive assignment' â€” `sum` will be\n// recalculated when `a` or `b` change. It is\n// not necessary to declare `sum` separately\n$: sum = a + b;\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating export let: In runes mode, are declared with the rune, allowing parent components to pass in data.","input":"In runes mode, are declared with the rune, allowing parent components to pass in data. In legacy mode, props are marked with the keyword, and can have a default value:","output":"<script>\nexport let foo;\nexport let bar = 'default value';\n\n// Values that are passed in as props\n// are immediately available\nconsole.log({ foo });\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating export let: An exported or declaration is a prop â€” instead, it becomes part of the component's API:","input":"An exported or declaration is a prop â€” instead, it becomes part of the component's API:","output":"<!file: Greeter.svelte>\n<script>\nexport function greet(name) {\n  alert(`hello ${name}!`);\n}\n</script>"}
{"instruction":"Write Svelte 5 code for export let.","input":"","output":"<!file: App.svelte>\n<script>\nimport Greeter from './Greeter.svelte';\n\nlet greeter;\n</script>\n\n<Greeter bind:this={greeter} />\n\n<button on:click={() => greeter.greet('world')}>\n  greet\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating export let: The keyword can appear separately from the declaration.","input":"The keyword can appear separately from the declaration. This is useful for renaming props, for example in the case of a reserved word:","output":"<!file: App.svelte>\n<script>\n/** @type {string} */\nlet className;\n\n// creates a `class` property, even\n// though it is a reserved word\nexport { className as class };\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating $$props and $$restProps: In runes mode, getting an object containing all the props that were passed in is easy, using the rune.","input":"In runes mode, getting an object containing all the props that were passed in is easy, using the rune. In legacy mode, we use and :","output":"<script>\nexport let variant;\n</script>\n\n<button {...$$restProps} class=\"variant-{variant} {$$props.class ?? ''}\">\n  click me\n</button>\n\n<style>\n.variant-danger {\n  background: red;\n}\n</style>"}
{"instruction":"Create a Svelte 5 component demonstrating on:: In runes mode, event handlers are just like any other attribute or prop.","input":"In runes mode, event handlers are just like any other attribute or prop. In legacy mode, we use the directive:","output":"<!file: App.svelte>\n<script>\nlet count = 0;\n\n/** @param {MouseEvent} event */\nfunction handleClick(event) {\n  count += 1;\n}\n</script>\n\n<button on:click={handleClick}>\n  count: {count}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating on:: Handlers can be declared inline with no performance penalty:","input":"Handlers can be declared inline with no performance penalty:","output":"<button on:click={() => (count += 1)}>\n  count: {count}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating on:: Add to element event handlers with the character.","input":"Add to element event handlers with the character.","output":"<form on:submit|preventDefault={handleSubmit}>\n</form>"}
{"instruction":"Create a Svelte 5 component demonstrating on:: If the directive is used without a value, the component will the event, meaning that a consumer of the component can listen for it.","input":"If the directive is used without a value, the component will the event, meaning that a consumer of the component can listen for it.","output":"<button on:click>\n  The component itself will emit the click event\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating on:: It's possible to have multiple event listeners for the same event:","input":"It's possible to have multiple event listeners for the same event:","output":"<!file: App.svelte>\n<script>\nlet count = 0;\n\nfunction increment() {\n  count += 1;\n}\n\n/** @param {MouseEvent} event */\nfunction log(event) {\n  console.log(event);\n}\n</script>\n\n<button on:click={increment} on:click={log}>\n  clicks: {count}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating on:: Components can dispatch events by creating a when they are initialised:","input":"Components can dispatch events by creating a when they are initialised:","output":"<script>\nimport { createEventDispatcher } from 'svelte';\n\nconst dispatch = createEventDispatcher();\n</script>\n\n<button on:click={() => dispatch('decrement')}>decrement</button>\n<button on:click={() => dispatch('increment')}>increment</button>"}
{"instruction":"Create a Svelte 5 component demonstrating on:: A consumer of this component can listen for the dispatched events:","input":"A consumer of this component can listen for the dispatched events:","output":"<script>\nimport Stepper from './Stepper.svelte';\n\nlet n = 0;\n</script>\n\n<Stepper\n  on:decrement={() => n -= 1}\n  on:increment={() => n += 1}\n/>\n\n<p>n: {n}</p>"}
{"instruction":"Create a Svelte 5 component demonstrating <slot>: In Svelte 5, content can be passed to components in the form of and rendered using .","input":"In Svelte 5, content can be passed to components in the form of and rendered using . In legacy mode, content inside component tags is considered which can be rendered by the component using a element:","output":"<!file: App.svelte>\n<script>\nimport Modal from './Modal.svelte';\n</script>\n\n<Modal>This is some slotted content</Modal>"}
{"instruction":"Write Svelte 5 code for <slot>.","input":"","output":"<!file: Modal.svelte>\n<div class=\"modal\">\n  <slot></slot>\n</div>"}
{"instruction":"Create a Svelte 5 component demonstrating <slot>: A component can have in addition to the default slot.","input":"A component can have in addition to the default slot. On the parent side, add a attribute to an element, component or directly inside the component tags.","output":"<!file: App.svelte>\n<script>\nimport Modal from './Modal.svelte';\n\nlet open = true;\n</script>\n\n{#if open}\n  <Modal>\n    This is some slotted content\n\n    <div slot=\"buttons\">\n      <button on:click={() => open = false}>\n        close\n      </button>\n    </div>\n  </Modal>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating <slot>: On the child side, add a corresponding element:","input":"On the child side, add a corresponding element:","output":"<!file: Modal.svelte>\n<div class=\"modal\">\n  <slot></slot>\n  <hr>\n  <slot name=\"buttons\"></slot>\n</div>"}
{"instruction":"Create a Svelte 5 component demonstrating <slot>: If no slotted content is provided, a component can define fallback content by putting it inside the element:","input":"If no slotted content is provided, a component can define fallback content by putting it inside the element:","output":"<slot>\n  This will be rendered if no slotted content is provided\n</slot>"}
{"instruction":"Create a Svelte 5 component demonstrating <slot>: Slots can be rendered zero or more times and can pass values to the parent using props.","input":"Slots can be rendered zero or more times and can pass values to the parent using props. The parent exposes the values to the slot template using the directive.","output":"<!file: FancyList.svelte>\n<ul>\n  {#each items as data}\n    <li class=\"fancy\">\n      <slot item={process(data)} />\n    </li>\n  {/each}\n</ul>"}
{"instruction":"Write Svelte 5 code for <slot>.","input":"","output":"<!file: App.svelte>\n<FancyList {items} let:item={processed}>\n  <div>{processed.text}</div>\n</FancyList>"}
{"instruction":"Create a Svelte 5 component demonstrating <slot>: Named slots can also expose values.","input":"Named slots can also expose values. The directive goes on the element with the attribute.","output":"<!file: FancyList.svelte>\n<ul>\n  {#each items as item}\n    <li class=\"fancy\">\n      <slot name=\"item\" item={process(data)} />\n    </li>\n  {/each}\n</ul>\n\n<slot name=\"footer\" />"}
{"instruction":"Write Svelte 5 code for <slot>.","input":"","output":"<!file: App.svelte>\n<FancyList {items}>\n  <div slot=\"item\" let:item>{item.text}</div>\n  <p slot=\"footer\">Copyright (c) 2019 Svelte Industries</p>\n</FancyList>"}
{"instruction":"Create a Svelte 5 component demonstrating $$slots: In runes mode, we know which were provided to a component, as they're just normal props.","input":"In runes mode, we know which were provided to a component, as they're just normal props. In legacy mode, the way to know if content was provided for a given slot is with the object, whose keys are the names of the slots passed into the component by the parent.","output":"<!file: Card.svelte>\n<div>\n  <slot name=\"title\" />\n  {#if $$slots.description}\n    <hr />\n    <slot name=\"description\" />\n  {/if}\n</div>"}
{"instruction":"Write Svelte 5 code for $$slots.","input":"","output":"<!file: App.svelte>\n<Card>\n  <h1 slot=\"title\">Blog Post Title</h1>\n</Card>"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:fragment>: The element allows you to place content in a without wrapping it in a container DOM element.","input":"The element allows you to place content in a without wrapping it in a container DOM element. This keeps the flow layout of your document intact.","output":"<!file: Widget.svelte>\n<div>\n  <slot name=\"header\">No header was provided</slot>\n  <p>Some content between header and footer</p>\n  <slot name=\"footer\" />\n</div>"}
{"instruction":"Write Svelte 5 code for <svelte:fragment>.","input":"","output":"<!file: App.svelte>\n<script>\nimport Widget from './Widget.svelte';\n</script>\n\n<Widget>\n  <h1 slot=\"header\">Hello</h1>\n  <svelte:fragment slot=\"footer\">\n    <p>All rights reserved.</p>\n    <p>Copyright (c) 2019 Svelte Industries</p>\n  </svelte:fragment>\n</Widget>"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:component>: In runes mode, will re-render if the value of changes.","input":"In runes mode, will re-render if the value of changes. See the for an example. In legacy mode, it won't â€” we must use which destroys and recreates the component instance when the value of its expression changes:","output":"<svelte:component this={MyComponent} />"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:self>: The element allows a component to include itself, recursively.","input":"The element allows a component to include itself, recursively. It cannot appear at the top level of your markup; it must be inside an if or each block or passed to a component's slot to prevent an infinite loop.","output":"<script>\nexport let count;\n</script>\n\n{#if count > 0}\n  <p>counting down... {count}</p>\n  <svelte:self count={count - 1} />\n{:else}\n  <p>lift-off!</p>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating Spring: A wrapper for a value that behaves in a spring-like fashion.","input":"A wrapper for a value that behaves in a spring-like fashion. Changes to will cause to move towards it over time, taking account of the and parameters.","output":"<script>\nimport { Spring } from 'svelte/motion';\n\nconst spring = new Spring(0);\n</script>\n\n<input type=\"range\" bind:value={spring.target} />\n<input type=\"range\" bind:value={spring.current} disabled />"}
{"instruction":"Create a Svelte 5 component demonstrating Spring: Create a spring whose value is bound to the return value of .","input":"Create a spring whose value is bound to the return value of . This must be called inside an effect root (for example, during component initialisation).","output":"<script>\nimport { Spring } from 'svelte/motion';\n\nlet { number } = $props();\nconst spring = Spring.of(() => number);\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Tween: A wrapper for a value that tweens smoothly to its target value.","input":"A wrapper for a value that tweens smoothly to its target value. Changes to will cause to move towards it over time, taking account of the and options.","output":"<script>\nimport { Tween } from 'svelte/motion';\n\nconst tween = new Tween(0);\n</script>\n\n<input type=\"range\" bind:value={tween.target} />\n<input type=\"range\" bind:value={tween.current} disabled />"}
{"instruction":"Create a Svelte 5 component demonstrating Tween: Create a tween whose value is bound to the return value of .","input":"Create a tween whose value is bound to the return value of . This must be called inside an effect root (for example, during component initialisation).","output":"<script>\nimport { Tween } from 'svelte/motion';\n\nlet { number } = $props();\nconst tween = Tween.of(() => number);\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating prefersReducedMotion: A that matches if the user .","input":"A that matches if the user .","output":"<script>\nimport { prefersReducedMotion } from 'svelte/motion';\nimport { fly } from 'svelte/transition';\n\nlet visible = $state(false);\n</script>\n\n<button onclick={() => visible = !visible}>\n  toggle\n</button>\n\n{#if visible}\n  <p transition:fly={{ y: prefersReducedMotion.current ? 0 : 200 }}>\n    flies in, unless the user prefers reduced motion\n  </p>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating SvelteURL: Svelte provides reactive versions of various built-ins like and .","input":"Svelte provides reactive versions of various built-ins like and . These can be imported from and used just like their native counterparts.","output":"<script>\nimport { SvelteURL } from 'svelte/reactivity';\n\nconst url = new SvelteURL('https://example.com/path');\n</script>\n\n<input bind:value={url.protocol} />\n<input bind:value={url.hostname} />\n<input bind:value={url.pathname} />\n\n<hr />\n\n<input bind:value={url.href} />"}
{"instruction":"Create a Svelte 5 component demonstrating MediaQuery: Creates a media query and provides a property that reflects whether or not it matches.","input":"Creates a media query and provides a property that reflects whether or not it matches. Use it carefully â€” during server-side rendering, there is no way to know what the correct value should be, potentially causing content to change upon hydration. If you can use the media query in CSS to achieve the same effect, do that.","output":"<script>\nimport { MediaQuery } from 'svelte/reactivity';\n\nconst large = new MediaQuery('min-width: 800px');\n</script>\n\n<h1>{large.current ? 'large screen' : 'small screen'}</h1>"}
{"instruction":"Write Svelte 5 code for $lib.","input":"SvelteKit automatically makes files under available using the import alias. You can change which directory this alias points to in your .","output":"<!file: src/lib/Component.svelte>\n"}
{"instruction":"Write Svelte 5 code for $lib.","input":"","output":"<!file: src/routes/+page.svelte>\n<script>\nimport Component from '$lib/Component.svelte';\n</script>\n\n<Component />"}
{"instruction":"Create a Svelte 5 component demonstrating page: A read-only reactive object with information about the current page, serving several use cases:","input":"A read-only reactive object with information about the current page, serving several use cases:","output":"<!file: +layout.svelte>\n<script>\nimport { page } from '$app/state';\n</script>\n\n<p>Currently at {page.url.pathname}</p>\n\n{#if page.error}\n  <span class=\"red\">Problem detected</span>\n{:else}\n  <span class=\"small\">All systems operational</span>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating page: Changes to are available exclusively with runes.","input":"Changes to are available exclusively with runes. (The legacy reactivity syntax will not reflect any changes)","output":"<!file: +page.svelte>\n<script>\nimport { page } from '$app/state';\n\nconst id = $derived(page.params.id);\n// This will correctly update id for usage on this page\n\n$: badId = page.params.id;\n// Do not use; will never update after initial load\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Snapshots: Ephemeral DOM state â€” like scroll positions on sidebars, the content of elements and so on â€” is discarded when you navigate from one page to another.","input":"Ephemeral DOM state â€” like scroll positions on sidebars, the content of elements and so on â€” is discarded when you navigate from one page to another. For example, if the user fills out a form but navigates away and then back before submitting, or if the user refreshes the page, the values they filled in will be lost. In cases where it's valuable to preserve that input, you can take a of DOM state, which can then be restored if the user navigates back. To do this, export a object with and methods from a or :","output":"<!file: +page.svelte>\n<script>\nlet comment = $state('');\n\n/** @type {import('./$types').Snapshot<string>} */\nexport const snapshot = {\n  capture: () => comment,\n  restore: (value) => comment = value\n};\n</script>\n\n<form method=\"POST\">\n  <label for=\"comment\">Comment</label>\n  <textarea id=\"comment\" bind:value={comment} />\n  <button>Post comment</button>\n</form>"}
{"instruction":"Create a Svelte 5 component demonstrating Shallow routing: As you navigate around a SvelteKit app, you create .","input":"As you navigate around a SvelteKit app, you create . Clicking the back and forward buttons traverses through this list of entries, re-running any functions and replacing page components as necessary. Sometimes, it's useful to create history entries navigating. For example, you might want to show a modal dialog that the user can dismiss by navigating back. This is particularly valuable on mobile devices, where swipe gestures are often more natural than interacting directly with the UI. In these cases, a modal that is associated with a history entry can be a source of frustration, as a user may swipe backwards in an attempt to dismiss it and find themselves on the wrong page. SvelteKit makes this possible with the and functions, which allow you to associate state with a history entry without navigating. For example, to implement a history-driven modal:","output":"<!file: +page.svelte>\n<script>\nimport { pushState } from '$app/navigation';\nimport { page } from '$app/state';\nimport Modal from './Modal.svelte';\n\nfunction showModal() {\n  pushState('', { showModal: true });\n}\n</script>\n\n{#if page.state.showModal}\n  <Modal close={() => history.back()} />\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating Shallow routing: When shallow routing, you may want to render another inside the current page.","input":"When shallow routing, you may want to render another inside the current page. For example, clicking on a photo thumbnail could pop up the detail view without navigating to the photo page. For this to work, you need to load the data that the expects. A convenient way to do this is to use inside the handler of an element. If the element (or a parent) uses the data will have already been requested, and will reuse that request.","output":"<!file: src/routes/photos/+page.svelte>\n<script>\nimport { preloadData, pushState, goto } from '$app/navigation';\nimport { page } from '$app/state';\nimport Modal from './Modal.svelte';\nimport PhotoPage from './[id]/+page.svelte';\n\nlet { data } = $props();\n</script>\n\n{#each data.thumbnails as thumbnail}\n  <a\n    href=\"/photos/{thumbnail.id}\"\n    onclick={async (e) => {\n      if (\n        innerWidth < 640 // bail if the screen is too small\n        || e.shiftKey // or the link is opened in a new window\n        || e.metaKey || e.ctrlKey // or a new tab (mac: metaKey, win/linux: ctrlKey)\n        // should also consider clicking with a mouse scroll wheel\n      ) return;\n\n      // prevent navigation\n      e.preventDefault();\n\n      const { href } = e.currentTarget;\n\n      // run `load` functions (or rather, get the result of the `load` functions\n      // that are already running because of `data-sveltekit-preload-data`)\n      const result = await preloadData(href);\n\n      if (result.type === 'loaded' && result.status === 200) {\n        pushState(href, { selected: result.data });\n      } else {\n        // something bad happened! try navigating\n        goto(href);\n      }\n    }}\n  >\n    <img alt={thumbnail.alt} src={thumbnail.src} />\n  </a>\n{/each}\n\n{#if page.state.selected}\n  <Modal onclose={() => history.back()}>\n    <PhotoPage data={page.state.selected} />\n  </Modal>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating <enhanced:img>: Use in your components by using rather than and referencing the image file with a path:","input":"Use in your components by using rather than and referencing the image file with a path:","output":"<enhanced:img src=\"./path/to/your/image.jpg\" alt=\"An alt text\" />"}
{"instruction":"Create a Svelte 5 component demonstrating <enhanced:img>: You can also manually import an image asset and pass it to an .","input":"You can also manually import an image asset and pass it to an . This is useful when you have a collection of static images and would like to dynamically choose one or . In this case you will need to update both the statement and element as shown below to indicate you'd like process them.","output":"<script>\nimport MyImage from './path/to/your/image.jpg?enhanced';\n</script>\n\n<enhanced:img src={MyImage} alt=\"some alt text\" />"}
{"instruction":"Create a Svelte 5 component demonstrating <enhanced:img>: You can also use .","input":"You can also use . Note that you will have to specify via a :","output":"<script>\n  const imageModules = import.meta.glob(\n    '/path/to/assets/*.{avif,gif,heif,jpeg,jpg,png,tiff,webp,svg}',\n    {\n      eager: true,\n      query: { enhanced: true }\n    }\n  )\n</script>\n\n{#each Object.entries(imageModules) as [_path, module]}\n  <enhanced:img src={module.default} alt=\"some alt text\" />\n{/each}"}
{"instruction":"Create a Svelte 5 component demonstrating <enhanced:img>: If you'd like to use a different and you can style the image with CSS.","input":"If you'd like to use a different and you can style the image with CSS. Because the preprocessor adds a and for you, if you'd like one of the dimensions to be automatically calculated then you will need to specify that:","output":"<style>\n  .hero-image img {\n    width: var(--size);\n    height: auto;\n  }\n</style>"}
{"instruction":"Create a Svelte 5 component demonstrating <enhanced:img>: If you have a large image, such as a hero image taking the width of the design, you should specify so that smaller versions are requested on smaller devices.","input":"If you have a large image, such as a hero image taking the width of the design, you should specify so that smaller versions are requested on smaller devices. E.g. if you have a 1280px image you may want to specify something like:","output":"<enhanced:img src=\"./image.png\" sizes=\"min(1280px, 100vw)\"/>"}
{"instruction":"Create a Svelte 5 component demonstrating <enhanced:img>: If is specified, will generate small images for smaller devices and populate the attribute.","input":"If is specified, will generate small images for smaller devices and populate the attribute. The smallest picture generated automatically will have a width of 540px. If you'd like smaller images or would otherwise like to specify custom widths, you can do that with the query parameter:","output":"<enhanced:img src=\"./image.png?w=1280;640;400\" sizes=\"(min-width:1920px) 1280px, (min-width:1080px) 640px, (min-width:768px) 400px\" />"}
{"instruction":"Create a Svelte 5 component demonstrating <enhanced:img>: By default, enhanced images will be transformed to more efficient formats.","input":"By default, enhanced images will be transformed to more efficient formats. However, you may wish to apply other transforms such as a blur, quality, flatten, or rotate operation. You can run per-image transforms by appending a query string:","output":"<enhanced:img src=\"./path/to/your/image.jpg?blur=15\" alt=\"An alt text\" />"}
{"instruction":"Create a Svelte 5 component demonstrating <title> and <meta>: Every page should have well-written and unique and elements inside a .","input":"Every page should have well-written and unique and elements inside a . Guidance on how to write descriptive titles and descriptions, along with other suggestions on making content understandable by search engines, can be found on Google's documentation.","output":""}
{"instruction":"Create a Svelte 5 component demonstrating Route announcements: In traditional server-rendered applications, every navigation (e.g.","input":"In traditional server-rendered applications, every navigation (e.g. clicking on an tag) triggers a full page reload. When this happens, screen readers and other assistive technology will read out the new page's title so that users understand that the page has changed. Since navigation between pages in SvelteKit happens without reloading the page (known as ), SvelteKit injects a onto the page that will read out the new page name after each navigation. This determines the page name to announce by inspecting the element. Because of this behavior, every page in your app should have a unique, descriptive title. In SvelteKit, you can do this by placing a element on each page:","output":"<!file: src/routes/+page.svelte>\n<svelte:head>\n  <title>Todo List</title>\n</svelte:head>"}
{"instruction":"Create a Svelte 5 component demonstrating Focus management: If you want to customize SvelteKit's focus management, you can use the hook:","input":"If you want to customize SvelteKit's focus management, you can use the hook:","output":""}
{"instruction":"Create a Svelte 5 component demonstrating Using state and stores with context: You might wonder how we're able to use and other (or ) if we can't use global state.","input":"You might wonder how we're able to use and other (or ) if we can't use global state. The answer is that app state and app stores on the server use Svelte's â€” the state (or store) is attached to the component tree with and when you subscribe you retrieve it with . We can do the same thing with our own state:","output":"<!file: src/routes/+layout.svelte>\n<script>\nimport { setContext } from 'svelte';\n\n/** @type {import('./$types').LayoutProps} */\nlet { data } = $props();\n\n// Pass a function referencing our state\n// to the context for child components to access\nsetContext('user', () => data.user);\n</script>"}
{"instruction":"Write Svelte 5 code for Using state and stores with context.","input":"","output":"<!file: src/routes/user/+page.svelte>\n<script>\nimport { getContext } from 'svelte';\n\n// Retrieve user store from context\nconst user = getContext('user');\n</script>\n\n<p>Welcome {user().name}</p>"}
{"instruction":"Create a Svelte 5 component demonstrating Component and page state is preserved: When you navigate around your application, SvelteKit reuses existing layout and page components.","input":"When you navigate around your application, SvelteKit reuses existing layout and page components. For example, if you have a route like this...","output":"<!file: src/routes/blog/[slug]/+page.svelte>\n<script>\n/** @type {import('./$types').PageProps} */\nlet { data } = $props();\n\n// THIS CODE IS BUGGY!\nconst wordCount = data.content.split(' ').length;\nconst estimatedReadingTime = wordCount / 250;\n</script>\n\n<header>\n  <h1>{data.title}</h1>\n  <p>Reading time: {Math.round(estimatedReadingTime)} minutes</p>\n</header>\n\n<div>{@html data.content}</div>"}
{"instruction":"Create a Svelte 5 component demonstrating Component and page state is preserved: ...then navigating from to won't cause the layout, page and any other components within to be destroyed and recreated.","input":"...then navigating from to won't cause the layout, page and any other components within to be destroyed and recreated. Instead the prop (and by extension and ) will update (as it would with any other Svelte component) and, because the code isn't rerunning, lifecycle methods like and won't rerun and won't be recalculated. Instead, we need to make the value :","output":"<script>\n/** @type {import('./$types').PageProps} */\nlet { data } = $props();\n\nlet wordCount = $derived(data.content.split(' ').length);\nlet estimatedReadingTime = $derived(wordCount / 250);\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Component and page state is preserved: Reusing components like this means that things like sidebar scroll state are preserved, and you can easily animate between changing values.","input":"Reusing components like this means that things like sidebar scroll state are preserved, and you can easily animate between changing values. In the case that you do need to completely destroy and remount a component on navigation, you can use this pattern:","output":"<script>\nimport { page } from '$app/state';\n</script>\n\n{#key page.url.pathname}\n  <BlogPost title={data.title} content={data.title} />\n{/key}"}
{"instruction":"Create a Svelte 5 component demonstrating +page.svelte: A component defines a page of your app.","input":"A component defines a page of your app. By default, pages are rendered both on the server () for the initial request and in the browser () for subsequent navigation.","output":"<!file: src/routes/+page.svelte>\n<h1>Hello and welcome to my site!</h1>\n<a href=\"/about\">About my site</a>"}
{"instruction":"Write Svelte 5 code for +page.svelte.","input":"","output":"<!file: src/routes/about/+page.svelte>\n<h1>About this site</h1>\n<p>TODO...</p>\n<a href=\"/\">Home</a>"}
{"instruction":"Create a Svelte 5 component demonstrating +page.svelte: Pages can receive data from functions via the prop.","input":"Pages can receive data from functions via the prop.","output":"<!file: src/routes/blog/[slug]/+page.svelte>\n<script>\n/** @type {import('./$types').PageProps} */\nlet { data } = $props();\n</script>\n\n<h1>{data.title}</h1>\n<div>{@html data.content}</div>"}
{"instruction":"Create a Svelte 5 component demonstrating +error: If an error occurs during SvelteKit will render a default error page.","input":"If an error occurs during SvelteKit will render a default error page. You can customise this error page on a per-route basis by adding an file:","output":"<!file: src/routes/blog/[slug]/+error.svelte>\n<script>\nimport { page } from '$app/state';\n</script>\n\n<h1>{page.status}: {page.error.message}</h1>"}
{"instruction":"Create a Svelte 5 component demonstrating +layout.svelte: To create a layout that applies to every page, make a file called .","input":"To create a layout that applies to every page, make a file called . The default layout (the one that SvelteKit uses if you don't bring your own) looks like this...","output":"<script>\nlet { children } = $props();\n</script>\n\n{@render children()}"}
{"instruction":"Create a Svelte 5 component demonstrating +layout.svelte: ...but we can add whatever markup, styles and behaviour we want.","input":"...but we can add whatever markup, styles and behaviour we want. The only requirement is that the component includes a tag for the page content. For example, let's add a nav bar:","output":"<!file: src/routes/+layout.svelte>\n<script>\nlet { children } = $props();\n</script>\n\n<nav>\n  <a href=\"/\">Home</a>\n  <a href=\"/about\">About</a>\n  <a href=\"/settings\">Settings</a>\n</nav>\n\n{@render children()}"}
{"instruction":"Create a Svelte 5 component demonstrating +layout.svelte: We can create a layout that only applies to pages below (while inheriting the root layout with the top-level nav):","input":"We can create a layout that only applies to pages below (while inheriting the root layout with the top-level nav):","output":"<!file: src/routes/settings/+layout.svelte>\n<script>\n/** @type {import('./$types').LayoutProps} */\nlet { data, children } = $props();\n</script>\n\n<h1>Settings</h1>\n\n<div class=\"submenu\">\n  {#each data.sections as section}\n    <a href=\"/settings/{section.slug}\">{section.title}</a>\n  {/each}\n</div>\n\n{@render children()}"}
{"instruction":"Create a Svelte 5 component demonstrating +layout.svelte: Data returned from a layout's function is also available to all its child pages:","input":"Data returned from a layout's function is also available to all its child pages:","output":"<script>\nimport { page } from '$app/state';\n\n/** @type {import('./$types').PageProps} */\nlet { data } = $props();\n\n// we can access `data.posts` because it's returned from\n// the parent layout `load` function\nlet index = $derived(data.posts.findIndex(post => post.slug === page.params.slug));\nlet next = $derived(data.posts[index + 1]);\n</script>\n\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#if next}\n  <p>Next post: <a href=\"/blog/{next.slug}\">{next.title}</a></p>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating +layout.svelte: The component, and each component above it, has access to its own data plus all the data from its parents.","input":"The component, and each component above it, has access to its own data plus all the data from its parents. In some cases, we might need the opposite â€” a parent layout might need to access page data or data from a child layout. For example, the root layout might want to access a property returned from a function in or . This can be done with :","output":"<!file: src/routes/+layout.svelte>\n<script>\nimport { page } from '$app/state';\n</script>\n\n<svelte:head>\n  <title>{page.data.title}</title>\n</svelte:head>"}
{"instruction":"Create a Svelte 5 component demonstrating +server: By exporting handlers, files can be used to create a complete API:","input":"By exporting handlers, files can be used to create a complete API:","output":"<!file: src/routes/add/+page.svelte>\n<script>\nlet a = 0;\nlet b = 0;\nlet total = 0;\n\nasync function add() {\n  const response = await fetch('/api/add', {\n    method: 'POST',\n    body: JSON.stringify({ a, b }),\n    headers: {\n      'content-type': 'application/json'\n    }\n  });\n  total = await response.json();\n}\n</script>\n\n<input type=\"number\" bind:value={a}>\n+\n<input type=\"number\" bind:value={b}>\n=\n{total}\n\n<button onclick={add}>Calculate</button>"}
{"instruction":"Create a Svelte 5 component demonstrating $types: For example, annotating with (or for a file) tells TypeScript that the type of is whatever was returned from :","input":"For example, annotating with (or for a file) tells TypeScript that the type of is whatever was returned from :","output":"<!file: src/routes/blog/[slug]/+page.svelte>\n<script>\n/** @type {import('./$types').PageProps} */\nlet { data } = $props();\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Default actions: To invoke this action from the page, just add a â€” no JavaScript needed:","input":"To invoke this action from the page, just add a â€” no JavaScript needed:","output":"<!file: src/routes/login/+page.svelte>\n<form method=\"POST\">\n  <label>\n    Email\n    <input name=\"email\" type=\"email\">\n  </label>\n  <label>\n    Password\n    <input name=\"password\" type=\"password\">\n  </label>\n  <button>Log in</button>\n</form>"}
{"instruction":"Create a Svelte 5 component demonstrating Named actions: To invoke a named action, add a query parameter with the name prefixed by a character:","input":"To invoke a named action, add a query parameter with the name prefixed by a character:","output":"<!file: src/routes/login/+page.svelte>\n<form method=\"POST\" action=\"?/register\">\n  \n</form>"}
{"instruction":"Create a Svelte 5 component demonstrating Named actions: As well as the attribute, we can use the attribute on a button to the same form data to a different action than the parent :","input":"As well as the attribute, we can use the attribute on a button to the same form data to a different action than the parent :","output":"<form method=\"POST\"action=\"?/login\">\n  <label>\n    Email\n    <input name=\"email\" type=\"email\">\n  </label>\n  <label>\n    Password\n    <input name=\"password\" type=\"password\">\n  </label>\n  <button>Log in</button>\n  <button formaction=\"?/register\">Register</button>\n</form>"}
{"instruction":"Create a Svelte 5 component demonstrating Anatomy of an action: Each action receives a object, allowing you to read the data with .","input":"Each action receives a object, allowing you to read the data with . After processing the request (for example, logging the user in by setting a cookie), the action can respond with data that will be available through the property on the corresponding page and through app-wide until the next update.","output":"<!file: src/routes/login/+page.svelte>\n<script>\n/** @type {import('./$types').PageProps} */\nlet { data, form } = $props();\n</script>\n\n{#if form?.success}\n  <p>Successfully logged in! Welcome back, {data.user.name}</p>\n{/if}\n\n"}
{"instruction":"Create a Svelte 5 component demonstrating Validation errors: If the request couldn't be processed because of invalid data, you can return validation errors â€” along with the previously submitted form values â€” back to the user so that they can try again.","input":"If the request couldn't be processed because of invalid data, you can return validation errors â€” along with the previously submitted form values â€” back to the user so that they can try again. The function lets you return an HTTP status code (typically 400 or 422, in the case of validation errors) along with the data. The status code is available through and the data through :","output":"<form method=\"POST\" action=\"?/login\">\n  {#if form?.missing}<p class=\"error\">The email field is required</p>{/if}\n  {#if form?.incorrect}<p class=\"error\">Invalid credentials!</p>{/if}\n\n  <label>\n    Email\n    <input name=\"email\" type=\"email\"value={form?.email ?? ''}>\n  </label>\n  <label>\n    Password\n    <input name=\"password\" type=\"password\">\n  </label>\n  <button>Log in</button>\n  <button formaction=\"?/register\">Register</button>\n</form>"}
{"instruction":"Create a Svelte 5 component demonstrating use:enhance: The easiest way to progressively enhance a form is to add the action:","input":"The easiest way to progressively enhance a form is to add the action:","output":"<script>\nimport { enhance } from '$app/forms';\n\n/** @type {import('./$types').PageProps} */\nlet { form } = $props();\n</script>\n\n<form method=\"POST\"use:enhance>\n  \n</form>"}
{"instruction":"Create a Svelte 5 component demonstrating Customising use:enhance: To customise the behaviour, you can provide a that runs immediately before the form is submitted, and (optionally) returns a callback that runs with the .","input":"To customise the behaviour, you can provide a that runs immediately before the form is submitted, and (optionally) returns a callback that runs with the . Note that if you return a callback, the default behavior mentioned above is not triggered. To get it back, call .","output":"<form\n  method=\"POST\"\n  use:enhance={({ formElement, formData, action, cancel, submitter }) => {\n    // `formElement` is this `<form>` element\n    // `formData` is its `FormData` object that's about to be submitted\n    // `action` is the URL to which the form is posted\n    // calling `cancel()` will prevent the submission\n    // `submitter` is the `HTMLElement` that caused the form to be submitted\n\n    return async ({ result, update }) => {\n      // `result` is an `ActionResult` object\n      // `update` is a function which triggers the default logic that would be triggered if this callback wasn't set\n    };\n  }}\n>\n  \n</form>"}
{"instruction":"Create a Svelte 5 component demonstrating Customising use:enhance: If you return a callback, you may need to reproduce part of the default behaviour, but without invalidating all data on a successful response.","input":"If you return a callback, you may need to reproduce part of the default behaviour, but without invalidating all data on a successful response. You can do so with :","output":"<script>\nimport { enhance,applyAction} from '$app/forms';\n\n/** @type {import('./$types').PageProps} */\nlet { form } = $props();\n</script>\n\n<form\n  method=\"POST\"\n  use:enhance={({ formElement, formData, action, cancel }) => {\n    return async ({ result }) => {\n      // `result` is an `ActionResult` object\n      if (result.type === 'redirect') {\n        goto(result.location);\n      } else {\n        await applyAction(result);\n      }\n    };\n  }}\n>\n  \n</form>"}
{"instruction":"Create a Svelte 5 component demonstrating Custom event listener: We can also implement progressive enhancement ourselves, without with a normal event listener on the :","input":"We can also implement progressive enhancement ourselves, without with a normal event listener on the :","output":"<!file: src/routes/login/+page.svelte>\n<script>\nimport { invalidateAll, goto } from '$app/navigation';\nimport { applyAction, deserialize } from '$app/forms';\n\n/** @type {import('./$types').PageProps} */\nlet { form } = $props();\n\n/** @param {SubmitEvent & { currentTarget: EventTarget & HTMLFormElement}} event */\nasync function handleSubmit(event) {\n  event.preventDefault();\n  const data = new FormData(event.currentTarget);\n\n  const response = await fetch(event.currentTarget.action, {\n    method: 'POST',\n    body: data\n  });\n\n  /** @type {import('@sveltejs/kit').ActionResult} */\n  const result = deserialize(await response.text());\n\n  if (result.type === 'success') {\n    // rerun all `load` functions, following the successful update\n    await invalidateAll();\n  }\n\n  applyAction(result);\n}\n</script>\n\n<form method=\"POST\" onsubmit={handleSubmit}>\n  \n</form>"}
{"instruction":"Create a Svelte 5 component demonstrating Alternatives: Form actions are the preferred way to send data to the server, since they can be progressively enhanced, but you can also use files to expose (for example) a JSON API.","input":"Form actions are the preferred way to send data to the server, since they can be progressively enhanced, but you can also use files to expose (for example) a JSON API. Here's how such an interaction could look like:","output":"<!file: src/routes/send-message/+page.svelte>\n<script>\nfunction rerun() {\n  fetch('/api/ci', { method: 'POST' });\n}\n</script>\n\n<button onclick={rerun}>Rerun CI</button>"}
{"instruction":"Write Svelte 5 code for Streaming with promises.","input":"This is useful for creating skeleton loading states, for example:","output":"<!file: src/routes/blog/[slug]/+page.svelte>\n<script>\n/** @type {import('./$types').PageProps} */\nlet { data } = $props();\n</script>\n\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}"}
{"instruction":"Write Svelte 5 code for Manual invalidation.","input":"Note that can be a custom identifier that starts with :","output":"<!file: src/routes/random-number/+page.svelte>\n<script>\nimport { invalidate, invalidateAll } from '$app/navigation';\n\n/** @type {import('./$types').PageProps} */\nlet { data } = $props();\n\nfunction rerunLoadFunction() {\n  // any of these will cause the `load` function to rerun\n  invalidate('app:random');\n  invalidate('https://api.example.com/random-number');\n  invalidate(url => url.href.includes('random-number'));\n  invalidateAll();\n}\n</script>\n\n<p>random number: {data.number}</p>\n\n<button onclick={rerunLoadFunction}>Update random number</button>"}
{"instruction":"Write Svelte 5 code for $types.","input":"The return types of the load functions are then available through the module as and respectively, while the union of the return values of all is available as . Starting with version 2.16.0, two additional helper types are provided: defines as well as when there are actions defined, while defines as well as .","output":"<!file: src/routes/+page.svelte>\n<script>\n/** @type {import('./$types').PageProps} */\nlet { data, form } = $props();\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating +layout@: Like pages, layouts can break out of their parent layout hierarchy, using the same technique.","input":"Like pages, layouts can break out of their parent layout hierarchy, using the same technique. For example, a component would reset the hierarchy for all its child routes.","output":""}
{"instruction":"Create a Svelte 5 component demonstrating When to use layout groups: Not all use cases are suited for layout grouping, nor should you feel compelled to use them.","input":"Not all use cases are suited for layout grouping, nor should you feel compelled to use them. It might be that your use case would result in complex nesting, or that you don't want to introduce a for a single outlier. It's perfectly fine to use other means such as composition (reusable functions or Svelte components) or if-statements to achieve what you want. The following example shows a layout that rewinds to the root layout and reuses components and functions that other layouts can also use:","output":"<!file: src/routes/nested/route/+layout@.svelte>\n<script>\nimport ReusableLayout from '$lib/ReusableLayout.svelte';\n\nlet { data, children } = $props();\n</script>\n\n<ReusableLayout {data}>\n  {@render children()}\n</ReusableLayout>"}
{"instruction":"Create a Svelte 5 component demonstrating Disabling options: To disable any of these options inside an element where they have been enabled, use the value:","input":"To disable any of these options inside an element where they have been enabled, use the value:","output":"<div data-sveltekit-preload-data>\n  <a href=\"/a\">a</a>\n  <a href=\"/b\">b</a>\n  <a href=\"/c\">c</a>\n\n  <div data-sveltekit-preload-data=\"false\">\n    <a href=\"/d\">d</a>\n    <a href=\"/e\">e</a>\n    <a href=\"/f\">f</a>\n  </div>\n</div>"}
{"instruction":"Create a Svelte 5 component demonstrating Disabling options: To apply an attribute to an element conditionally, do this:","input":"To apply an attribute to an element conditionally, do this:","output":"<div data-sveltekit-preload-data={condition ? 'hover' : false}>\n  \n</div>"}
{"instruction":"Create a Svelte 5 component demonstrating bundleStrategy?: 'split' | 'single' | 'inline';: If you want to inline your assets, you'll need to set Vite's option to an appropriate size then import your assets through Vite.","input":"If you want to inline your assets, you'll need to set Vite's option to an appropriate size then import your assets through Vite.","output":"<script>\n// import the asset through Vite\nimport favicon from './favicon.png';\n</script>\n\n<svelte:head>\n  <link rel=\"icon\" href={favicon} />\n</svelte:head>"}
{"instruction":"Write Svelte 5 code for version.","input":"If you set to a non-zero value, SvelteKit will poll for new versions in the background and set the value of when it detects one.","output":"<script>\nimport { beforeNavigate } from '$app/navigation';\nimport { updated } from '$app/state';\n\nbeforeNavigate(({ willUnload, to }) => {\n  if (updated.current && !willUnload && to?.url) {\n    location.href = to.url.href;\n  }\n});\n</script>"}
{"instruction":"Write Svelte 5 code for How do I use the view transitions API?.","input":"For more, see on the Svelte blog.","output":""}
{"instruction":"Write Svelte 5 code for How do I use a client-side library accessing `document` or `window`?.","input":"If the library you'd like to use is side-effect free you can also statically import it and it will be tree-shaken out in the server-side build where will be automatically replaced with a no-op:","output":""}
{"instruction":"Create a Svelte 5 component demonstrating How do I use a client-side library accessing `document` or `window`?: Finally, you may also consider using an block:","input":"Finally, you may also consider using an block:","output":"<!file: index.svelte>\n<script>\nimport { browser } from '$app/environment';\n\nconst ComponentConstructor = browser\n  ? import('some-browser-only-library').then((module) => module.Component)\n  : new Promise(() => {});\n</script>\n\n{#await ComponentConstructor}\n  <p>Loading...</p>\n{:then component}\n  <svelte:component this={component} />\n{:catch error}\n  <p>Something went wrong: {error.message}</p>\n{/await}"}
{"instruction":"Create a Svelte 5 component demonstrating SvelteComponentTyped is deprecated: If you have used as the component instance type previously, you may see a somewhat opaque type error now, which is solved by changing to .","input":"If you have used as the component instance type previously, you may see a somewhat opaque type error now, which is solved by changing to .","output":"<script>\nimport ComponentA from './ComponentA.svelte';\nimport ComponentB from './ComponentB.svelte';\nimport { SvelteComponent } from 'svelte';\n\nlet component: typeof SvelteComponent<any>;\n\nfunction choseRandomly() {\n  component = Math.random() > 0.5 ? ComponentA : ComponentB;\n}\n</script>\n\n<button on:click={choseRandomly}>random</button>\n<svelte:element this={component} />"}
{"instruction":"Create a Svelte 5 component demonstrating Default slot bindings: Default slot bindings are no longer exposed to named slots and vice versa:","input":"Default slot bindings are no longer exposed to named slots and vice versa:","output":"<script>\nimport Nested from './Nested.svelte';\n</script>\n\n<Nested let:count>\n  <p>\n    count in default slot - is available: {count}\n  </p>\n  <p slot=\"bar\">\n    count in bar slot - is not available: {count}\n  </p>\n</Nested>"}
{"instruction":"Create a Svelte 5 component demonstrating let â†’ $state: Let's migrate the counter to runes mode by wrapping the counter in :","input":"Let's migrate the counter to runes mode by wrapping the counter in :","output":"<script>\nlet count =$state(0);\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating $: â†’ $derived/$effect: In Svelte 4, a statement at the top level of a component could be used to declare a derivation, i.e.","input":"In Svelte 4, a statement at the top level of a component could be used to declare a derivation, i.e. state that is entirely defined through a computation of other state. In Svelte 5, this is achieved using the rune:","output":"<script>\nlet count = $state(0);\n$:constdouble =$derived(count * 2);\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating $: â†’ $derived/$effect: A statement could also be used to create side effects.","input":"A statement could also be used to create side effects. In Svelte 5, this is achieved using the rune:","output":"<script>\nlet count = $state(0);\n\n$:$effect(() =>{\n  if (count > 5) {\n    alert('Count is too high!');\n  }\n});\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating export let â†’ $props: In Svelte 4, properties of a component were declared using .","input":"In Svelte 4, properties of a component were declared using . Each property was one declaration. In Svelte 5, all properties are declared through the rune, through destructuring:","output":"<script>\nexport let optional = 'unset';\nexport let required;\n\nlet { optional = 'unset', required } = $props();\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating export let â†’ $props: In Svelte 5, the rune makes this straightforward without any additional Svelte-specific syntax:","input":"In Svelte 5, the rune makes this straightforward without any additional Svelte-specific syntax:","output":"<script>\nlet klass = '';\nexport { klass as class};\n\nlet { class: klass, ...rest } = $props();\n</script>\n\n<button class={klass} {...$$restPropsrest}>click me</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Event changes: Event handlers have been given a facelift in Svelte 5.","input":"Event handlers have been given a facelift in Svelte 5. Whereas in Svelte 4 we use the directive to attach an event listener to an element, in Svelte 5 they are properties like any other (in other words - remove the colon):","output":"<script>\nlet count = $state(0);\n</script>\n\n<button on:click={() => count++}>\n  clicks: {count}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Event changes: Since they're just properties, you can use the normal shorthand syntax...","input":"Since they're just properties, you can use the normal shorthand syntax...","output":"<script>\nlet count = $state(0);\n\nfunction onclick() {\n  count++;\n}\n</script>\n\n<button {onclick}>\n  clicks: {count}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Component events: In Svelte 4, components could emit events by creating a dispatcher with .","input":"In Svelte 4, components could emit events by creating a dispatcher with . This function is deprecated in Svelte 5. Instead, components should accept - which means you then pass functions as properties to these components:","output":"<!file: App.svelte>\n<script>\nimport Pump from './Pump.svelte';\n\nlet size = $state(15);\nlet burst = $state(false);\n\nfunction reset() {\n  size = 15;\n  burst = false;\n}\n</script>\n\n<Pump\n  on:inflate={(power) => {\n    size += power.detail;\n    if (size > 75) burst = true;\n  }}\n  on:deflate={(power) => {\n    if (size > 0) size -= power.detail;\n  }}\n/>\n\n{#if burst}\n  <button onclick={reset}>new balloon</button>\n  <span class=\"boom\">ðŸ’¥</span>\n{:else}\n  <span class=\"balloon\" style=\"scale: {0.01 * size}\">\n    ðŸŽˆ\n  </span>\n{/if}"}
{"instruction":"Write Svelte 5 code for Component events.","input":"","output":"<!file: Pump.svelte>\n<script>\nimport { createEventDispatcher } from 'svelte';\nconst dispatch = createEventDispatcher();\n\nlet { inflate, deflate } = $props();\nlet power = $state(5);\n</script>\n\n<button onclick={() =>dispatch('inflate', power)inflate(power)}>\n  inflate\n</button>\n\n<button onclick={() =>dispatch('deflate', power)deflate(power)}>\n  deflate\n</button>\n\n<button onclick={() => power--}>-</button>\nPump power: {power}\n<button onclick={() => power++}>+</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Bubbling events: Instead of doing to 'forward' the event from the element to the component, the component should accept an callback prop:","input":"Instead of doing to 'forward' the event from the element to the component, the component should accept an callback prop:","output":"<script>\nlet { onclick } = $props();\n</script>\n\n<buttonon:click{onclick}>\n  click me\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Bubbling events: Note that this also means you can 'spread' event handlers onto the element along with other props instead of tediously forwarding each event separately:","input":"Note that this also means you can 'spread' event handlers onto the element along with other props instead of tediously forwarding each event separately:","output":"<script>\nlet props = $props();\n</script>\n\n<button{...$$props} on:click on:keydown on:all_the_other_stuff{...props}>\n  click me\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Event modifiers: In Svelte 4, you can add event modifiers to handlers:","input":"In Svelte 4, you can add event modifiers to handlers:","output":"<button on:click|once|preventDefault={handler}>...</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Event modifiers: Since event handlers are just functions, you can create your own wrappers as necessary:","input":"Since event handlers are just functions, you can create your own wrappers as necessary:","output":"<script>\nfunction once(fn) {\n  return function (event) {\n    if (fn) fn.call(this, event);\n    fn = null;\n  };\n}\n\nfunction preventDefault(fn) {\n  return function (event) {\n    event.preventDefault();\n    fn.call(this, event);\n  };\n}\n</script>\n\n<button onclick={once(preventDefault(handler))}>...</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Event modifiers: For we add the modifier to the event name:","input":"For we add the modifier to the event name:","output":"<button onclickcapture={...}>...</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Multiple event handlers: In Svelte 4, this is possible:","input":"In Svelte 4, this is possible:","output":"<button on:click={one} on:click={two}>...</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Multiple event handlers: Duplicate attributes/properties on elements â€” which now includes event handlers â€” are not allowed.","input":"Duplicate attributes/properties on elements â€” which now includes event handlers â€” are not allowed. Instead, do this:","output":"<button onclick={(e) => {\n    one(e);\n    two(e);\n  }}\n>\n  ...\n</button>"}